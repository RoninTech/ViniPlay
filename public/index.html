<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARDO IPTV Player</title>
    <link rel="icon" type="image/png" href="https://i.imgur.com/o1cAhBo.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/mpegts.js/dist/mpegts.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* gray-900 */
            color: #d1d5db; /* gray-300 */
        }
        .custom-scrollbar::-webkit-scrollbar { height: 8px; width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1f2937; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .tab-button.active { background-color: #3b82f6; color: white; }
        .bottom-nav-btn.active { color: #3b82f6; }
        .data-tab-button.active { color: #3b82f6; font-weight: 600; border-bottom-color: #3b82f6; }
        .programme-item { border-left: 3px solid #3b82f6; transition: background-color 0.3s, border-color 0.3s, opacity 0.3s; }
        .programme-item:hover { background-color: #374151; cursor: pointer; }
        html, body { height: 100%; overflow: hidden; }
        .favorite-star { transition: color 0.2s, transform 0.2s; }
        .favorite-star.favorited { color: #facc15; transform: scale(1.2); }
        .programme-progress { position: absolute; top: 0; left: 0; bottom: 0; background-color: rgba(59, 130, 246, 0.3); border-radius: 2px 0 0 2px; pointer-events: none; transition: width 0.3s linear; }
        .programme-item.past { background-color: #374151; border-left-color: #6b7280; opacity: 0.6; }
        .programme-item.live { border-left: 4px solid #fb923c; background-color: #374151; }
        .programme-item.live::after { content: 'LIVE'; position: absolute; top: 4px; right: 4px; background-color: #ef4444; color: white; padding: 1px 4px; font-size: 0.65rem; font-weight: 700; border-radius: 4px; z-index: 20; }
        .programme-item .prog-title { font-size: 0.9rem; font-weight: 600; }
        .programme-item .prog-time { font-size: 0.75rem; }
        #group-filter, #search-input, #timezone-offset-select { transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease; }
        #group-filter:hover, #search-input:hover, #timezone-offset-select:hover { background-color: #4b5563; }
        #channel-panel-container { transition: transform 0.3s ease-in-out; }
        #sidebar-overlay { transition: opacity 0.3s ease-in-out; }
        body.modal-open { overflow: hidden; }
        .programme-item.highlighted { outline: 3px solid #facc15; z-index: 15; transition: outline 0.2s ease-in-out; }
    </style>
</head>
<body class="flex flex-col h-screen">

    <header class="bg-gray-800 text-white p-4 shadow-md z-30 flex-shrink-0 flex items-center justify-between">
        <div class="flex items-center gap-3">
            <img src="https://i.imgur.com/o1cAhBo.png" alt="ARDO IPTV Player Logo" class="h-8 w-8">
            <h1 class="text-xl sm:text-2xl font-bold">ARDO IPTV Player</h1>
        </div>
        <button id="sidebar-toggle" class="lg:hidden p-2 rounded-md hover:bg-gray-700">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
        </button>
    </header>

    <div class="hidden lg:flex border-b border-gray-700 bg-gray-800 flex-shrink-0 z-20">
        <button id="tab-guide" class="tab-button text-sm sm:text-base font-medium py-3 px-6 text-gray-300 hover:bg-gray-700">TV Guide</button>
        <button id="tab-settings" class="tab-button text-sm sm:text-base font-medium py-3 px-6 text-gray-300 hover:bg-gray-700 active">Settings</button>
    </div>

    <main class="flex-grow flex flex-col overflow-hidden">
        <div id="page-guide" class="hidden flex-grow flex-col overflow-hidden">
            <div class="flex flex-wrap items-center justify-between gap-4 p-2 sm:p-4 border-b border-gray-700 flex-shrink-0">
                <div class="flex items-center gap-2">
                    <button id="prev-day-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-3 rounded-md text-sm transition-colors">&lt;</button>
                    <button id="now-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md text-sm transition-colors">Now</button>
                    <button id="next-day-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-3 rounded-md text-sm transition-colors">&gt;</button>
                </div>
                <div id="guide-date-display" class="text-base sm:text-lg font-semibold text-center flex-grow"></div>
                <div class="relative w-full sm:w-auto flex items-center gap-2">
                    <input type="search" id="search-input" placeholder="Search channels & programs..." class="w-full sm:w-64 bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-sm text-white focus:ring-blue-500 focus:border-blue-500">
                    <button id="today-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-3 rounded-md text-sm transition-colors flex-shrink-0">Reset view</button>
                    <div id="search-results-container" class="hidden absolute top-full right-0 w-full sm:w-96 max-h-80 overflow-y-auto bg-gray-800 border border-gray-600 rounded-md mt-1 z-50 custom-scrollbar shadow-lg"></div>
                </div>
            </div>
            <div id="guide-container" class="flex-grow flex bg-gray-900 overflow-hidden relative">
                <div id="guide-placeholder" class="absolute inset-0 flex items-center justify-center z-40">
                    <div class="text-center text-gray-500 p-4">
                        <svg class="mx-auto h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
                        <h3 class="mt-2 text-sm font-medium">No Data Loaded</h3>
                        <p class="mt-1 text-sm">Go to the Settings tab to load your M3U and EPG files.</p>
                    </div>
                </div>
                <div id="sidebar-overlay" class="fixed inset-0 bg-black/50 z-40 hidden lg:hidden"></div>
                <div id="channel-panel-container" class="absolute lg:relative inset-y-0 left-0 w-64 sm:w-80 bg-gray-800/80 lg:bg-gray-800 backdrop-blur-sm lg:backdrop-blur-none z-50 transform -translate-x-full lg:transform-none lg:translate-x-0 min-w-[250px] max-w-[80vw] lg:max-w-[30vw] flex-shrink-0 flex flex-col hidden lg:flex">
                    <div class="h-16 flex items-center justify-between p-2 border-b border-gray-700/80 flex-shrink-0">
                         <select id="group-filter" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500 hidden"></select>
                    </div>
                    <div id="channel-list" class="overflow-y-auto custom-scrollbar flex-grow"></div>
                </div>
                <div id="resizer" class="hidden lg:block w-1.5 cursor-col-resize bg-gray-700 hover:bg-blue-500 z-10"></div>
                <div id="logo-column" class="flex flex-col lg:hidden w-20 flex-shrink-0 bg-gray-900 border-r border-gray-700/50">
                    <div class="h-16 flex-shrink-0 border-b border-gray-700/80"></div>
                    <div id="logo-list" class="overflow-y-auto custom-scrollbar flex-grow"></div>
                </div>
                <div id="timeline-container" class="flex-grow flex flex-col overflow-hidden">
                    <div id="time-bar" class="h-16 bg-gray-800/80 flex-shrink-0 relative z-10 overflow-x-hidden"></div>
                    <div id="guide-timeline" class="overflow-auto custom-scrollbar relative flex-grow">
                        <div id="now-line" class="absolute top-0 bottom-0 bg-red-500 w-0.5 z-20 hidden"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="page-settings" class="flex-grow flex-col items-center p-4 overflow-y-auto custom-scrollbar">
            <div class="w-full max-w-4xl mx-auto space-y-8 pb-16">
                <div class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold text-white mb-4 border-b border-gray-700 pb-2">Load Guide Data</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-8">
                        <div>
                            <label class="block text-sm font-medium text-gray-400 mb-2">1. M3U Source</label>
                            <div class="flex border-b border-gray-600">
                                <button id="m3u-tab-file" class="data-tab-button flex-1 py-2 text-sm">From File</button>
                                <button id="m3u-tab-url" class="data-tab-button active flex-1 py-2 text-sm">From URL</button>
                            </div>
                            <div id="m3u-content-file" class="hidden mt-4"><input type="file" id="m3u-upload" name="m3u-file" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600 cursor-pointer"></div>
                            <div id="m3u-content-url" class="mt-4">
                                <div class="space-y-2">
                                    <select id="m3u-url-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500">
                                        <option value="custom">Custom URL...</option>
                                    </select>
                                    <div id="m3u-custom-container" class="hidden flex gap-2 mt-2">
                                        <input type="url" id="m3u-url-input" placeholder="Enter custom M3U URL..." class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500">
                                        <button id="save-m3u-url-btn" title="Save URL to list" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md flex-shrink-0">Save</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-400 mb-2">2. EPG Source (Optional)</label>
                            <div class="flex border-b border-gray-600">
                                <button id="epg-tab-file" class="data-tab-button flex-1 py-2 text-sm">From File</button>
                                <button id="epg-tab-url" class="data-tab-button active flex-1 py-2 text-sm">From URL</button>
                            </div>
                            <div id="epg-content-file" class="hidden mt-4"><input type="file" id="epg-upload" name="epg-file" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600 cursor-pointer"></div>
                            <div id="epg-content-url" class="mt-4">
                                <div class="space-y-2">
                                    <select id="epg-url-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500">
                                        <option value="custom">Custom URL...</option>
                                    </select>
                                    <div id="epg-custom-container" class="hidden flex gap-2 mt-2">
                                        <input type="url" id="epg-url-input" placeholder="Enter custom EPG URL..." class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500">
                                        <button id="save-epg-url-btn" title="Save URL to list" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md flex-shrink-0">Save</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="md:col-span-2">
                            <button id="load-guide-btn" class="w-full bg-green-600 hover:bg-green-700 disabled:bg-green-800 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-md transition-colors flex items-center justify-center gap-2">
                                <span id="load-guide-btn-content">
                                    <svg class="w-5 h-5 inline-block -mt-1 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                                    <span>Load Guide & View</span>
                                </span>
                            </button>
                        </div>
                    </div>
                </div>

                <div class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold text-white mb-4 border-b border-gray-700 pb-2">App Settings</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="auto-refresh-select" class="block text-sm font-medium text-gray-400 mb-1">Auto Refresh URL Data</label>
                            <select id="auto-refresh-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500">
                                <option value="0">Disabled</option>
                                <option value="1">Every 1 Hour</option>
                                <option value="4">Every 4 Hours</option>
                                <option value="12">Every 12 Hours</option>
                                <option value="24">Every 24 Hours</option>
                            </select>
                        </div>
                        <div>
                            <label for="timezone-offset-select" class="block text-sm font-medium text-gray-400 mb-1">EPG Timezone Correction</label>
                             <p class="text-xs text-gray-500 mb-2">Use this if EPG times are wrong. It only affects programs without timezone info.</p>
                            <select id="timezone-offset-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500"></select>
                        </div>
                    </div>
                </div>
            
                <div class="bg-red-900/50 border border-red-700/50 p-4 sm:p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold text-red-300 mb-4 border-b border-red-700/50 pb-2">Danger Zone</h2>
                    <p class="text-sm text-gray-400 mb-4">This permanently deletes all saved application data from the server.</p>
                    <button id="clear-data-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-md flex items-center justify-center gap-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg><span>Clear All Data & Reset</span></button>
                </div>
            </div>
        </div>
    </main>
    
    <nav class="lg:hidden bg-gray-800 border-t border-gray-700 flex justify-around flex-shrink-0 z-20">
        <button id="bottom-nav-guide" class="bottom-nav-btn flex-1 p-3 text-gray-400">
            <svg class="mx-auto h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path></svg>
            <span class="text-xs">Guide</span>
        </button>
        <button id="bottom-nav-settings" class="bottom-nav-btn flex-1 p-3 text-gray-400 active">
            <svg class="mx-auto h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0 3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            <span class="text-xs">Settings</span>
        </button>
    </nav>

    <div id="video-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
        <div class="bg-gray-900 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center p-3 border-b border-gray-700">
                <h3 id="video-title" class="text-lg font-semibold text-white truncate"></h3>
                <div class="flex items-center gap-2">
                    <button id="pip-btn" class="text-gray-400 hover:text-white p-2 rounded-md hover:bg-gray-700" title="Picture-in-Picture"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M12.5 5.5h-5a1 1 0 00-1 1v2.5a.5.5 0 001 0v-2a.5.5 0 01.5-.5h4a.5.5 0 01.5.5v4a.5.5 0 01-.5.5h-2a.5.5 0 000 1h2.5a1 1 0 001-1v-5a1 1 0 00-1-1z"></path><path d="M3.5 3A1.5 1.5 0 002 4.5v11A1.5 1.5 0 003.5 17h13a1.5 1.5 0 001.5-1.5v-11A1.5 1.5 0 0016.5 3h-13zm0 1h13a.5.5 0 01.5.5v11a.5.5 0 01-.5.5h-13a.5.5 0 01-.5-.5v-11a.5.5 0 01.5-.5z"></path></svg></button>
                    <button id="close-modal" class="text-gray-400 hover:text-white text-3xl leading-none font-bold">&times;</button>
                </div>
            </div>
            <div class="flex-grow p-1 bg-black"><video id="videoElement" controls autoplay class="w-full h-full"></video></div>
        </div>
    </div>
    
    <div id="program-details-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl w-full max-w-lg p-6">
            <h3 id="details-title" class="text-xl font-bold text-white mb-2"></h3>
            <p id="details-time" class="text-sm text-gray-400 mb-4"></p>
            <p id="details-desc" class="text-base text-gray-300 mb-6 max-h-40 overflow-y-auto custom-scrollbar"></p>
            <div class="flex justify-between items-center gap-4">
                <button id="details-play-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md">Play Channel</button>
                <button id="details-close-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md">Close</button>
            </div>
        </div>
    </div>
    
    <div id="notification-modal" class="hidden fixed top-5 right-5 bg-red-500 text-white py-2 px-4 rounded-lg shadow-lg z-[100]"><p id="notification-message"></p></div>

    <div id="confirm-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl w-full max-w-md p-6">
            <h3 id="confirm-title" class="text-lg font-bold text-white mb-2"></h3>
            <p id="confirm-message" class="text-gray-400 mb-6"></p>
            <div class="flex justify-end gap-4">
                <button id="confirm-cancel-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md">Cancel</button>
                <button id="confirm-ok-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md">Confirm</button>
            </div>
        </div>
    </div>
    
    <script id="parser-worker" type="javascript/worker">
        function parseEpgTime(timeStr, offsetHours = 0) {
            const match = timeStr.match(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})\s*(([+-])(\d{2})(\d{2}))?/);
            if (match) {
                const [ , year, month, day, hours, minutes, seconds, , sign, tzHours, tzMinutes] = match;
                let date;
                if (sign && tzHours && tzMinutes) {
                    const epgOffsetMinutes = (parseInt(tzHours) * 60 + parseInt(tzMinutes)) * (sign === '+' ? 1 : -1);
                    date = new Date(Date.UTC(year, parseInt(month) - 1, day, hours, minutes, seconds));
                    date.setUTCMinutes(date.getUTCMinutes() - epgOffsetMinutes);
                } else {
                    date = new Date(Date.UTC(year, parseInt(month) - 1, day, hours, minutes, seconds));
                    date.setUTCHours(date.getUTCHours() - offsetHours);
                }
                return date;
            }
            return new Date();
        }
        function parseM3U(data) {
            const lines = data.split('\n');
            const channels = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('#EXTINF:')) {
                    const nextLine = lines[i + 1]?.trim();
                    if (nextLine && (nextLine.startsWith('http') || nextLine.startsWith('rtp'))) {
                        const idMatch = line.match(/tvg-id="([^"]*)"/);
                        const logoMatch = line.match(/tvg-logo="([^"]*)"/);
                        const nameMatch = line.match(/tvg-name="([^"]*)"/);
                        const groupMatch = line.match(/group-title="([^"]*)"/);
                        const commaIndex = line.lastIndexOf(',');
                        const displayName = (commaIndex !== -1) ? line.substring(commaIndex + 1).trim() : 'Unknown';
                        channels.push({
                            id: idMatch ? idMatch[1] : `unknown-${Math.random()}`,
                            logo: logoMatch ? logoMatch[1] : '',
                            name: nameMatch ? nameMatch[1] : displayName,
                            group: groupMatch ? groupMatch[1] : 'Uncategorized',
                            displayName: displayName,
                            url: nextLine
                        });
                        i++;
                    }
                }
            }
            return channels;
        }
        function parseEPG(xmlString, timezoneOffset) {
            const programData = {};
            const programmeRegex = /<programme([^>]+)>([\s\S]*?)<\/programme>/g;
            const channelRegex = /channel="([^"]+)"/;
            const startRegex = /start="([^"]+)"/;
            const stopRegex = /stop="([^"]+)"/;
            const titleRegex = /<title[^>]*>([\s\S]*?)<\/title>/;
            const descRegex = /<desc[^>]*>([\s\S]*?)<\/desc>/;
            let match;
            while ((match = programmeRegex.exec(xmlString)) !== null) {
                const [, attributes, content] = match;
                const channelMatch = attributes.match(channelRegex);
                const startMatch = attributes.match(startRegex);
                const stopMatch = attributes.match(stopRegex);
                if (!channelMatch || !startMatch || !stopMatch) continue;
                const channelId = channelMatch[1];
                const titleMatch = content.match(titleRegex);
                if (!programData[channelId]) programData[channelId] = [];
                programData[channelId].push({
                    start: parseEpgTime(startMatch[1], timezoneOffset),
                    stop: parseEpgTime(stopMatch[1], timezoneOffset),
                    title: titleMatch ? titleMatch[1].replace(/<!\[CDATA\[|\]\]>/g, '').trim() : 'No Title',
                    desc: content.match(descRegex)?.[1].replace(/<!\[CDATA\[|\]\]>/g, '').trim() || ''
                });
            }
            for (const channelId in programData) {
                programData[channelId].sort((a, b) => a.start - b.start);
            }
            return programData;
        }
        self.onmessage = function(e) {
            const { type, data, timezoneOffset } = e.data;
            try {
                if (type === 'm3u') self.postMessage({ type: 'm3u-success', data: parseM3U(data) });
                else if (type === 'epg') self.postMessage({ type: 'epg-success', data: parseEPG(data, timezoneOffset) });
            } catch (error) {
                self.postMessage({ type: 'parse-error', error: error.message });
            }
        };
    </script>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Global State & Configuration ---
            const guideState = {
                channels: [],
                programs: {},
                settings: {}, // Populated from server on init
                guideDurationHours: 48,
                hourWidthPixels: window.innerWidth < 768 ? 200 : 300,
                currentDate: new Date(),
                channelGroups: new Set(),
            };
            let player, worker, autoRefreshIntervalId, searchDebounceTimer;
            let confirmCallback = null;
            
            // A helper to quickly grab all UI elements with an ID
            const UIElements = Object.fromEntries(
                [...document.querySelectorAll('[id]')].map(el => [
                    el.id.replace(/-(\w)/g, (match, letter) => letter.toUpperCase()), 
                    el
                ])
            );

            // --- Server Communication ---
            async function saveSettings() {
                try {
                    await fetch('/api/save/settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(guideState.settings)
                    });
                } catch (error) {
                    console.error("Failed to save settings:", error);
                    showNotification("Could not sync settings with server.", true);
                }
            }
            
            // --- UI Helper Functions ---
            const showNotification = (message, isError = false, duration = 3000) => {
                UIElements.notificationMessage.textContent = message;
                UIElements.notificationModal.className = `fixed top-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg z-[100] ${isError ? 'bg-red-500' : 'bg-green-500'}`;
                setTimeout(() => { UIElements.notificationModal.classList.add('hidden'); }, duration);
            };

            const switchTab = (activeTab) => {
                const isGuide = activeTab === 'guide';
                ['tabGuide', 'bottomNavGuide'].forEach(id => UIElements[id].classList.toggle('active', isGuide));
                ['tabSettings', 'bottomNavSettings'].forEach(id => UIElements[id].classList.toggle('active', !isGuide));
                UIElements.pageGuide.classList.toggle('hidden', !isGuide);
                UIElements.pageGuide.classList.toggle('flex', isGuide);
                UIElements.pageSettings.classList.toggle('hidden', isGuide);
                UIElements.pageSettings.classList.toggle('flex', !isGuide);
                UIElements.sidebarToggle.classList.toggle('hidden', !isGuide);
            };

            const openModal = (modal) => { modal.classList.replace('hidden', 'flex'); document.body.classList.add('modal-open'); };
            const closeModal = (modal) => {
                modal.classList.replace('flex', 'hidden');
                if (!document.querySelector('.fixed.inset-0.flex')) document.body.classList.remove('modal-open');
            };
            
            const showConfirm = (title, message, callback) => {
                UIElements.confirmTitle.textContent = title;
                UIElements.confirmMessage.textContent = message;
                confirmCallback = callback;
                openModal(UIElements.confirmModal);
            };

            const toggleSidebar = (show) => {
                 UIElements.sidebarOverlay.classList.toggle('hidden', !show);
                 UIElements.channelPanelContainer.classList.toggle('-translate-x-full', !show);
            };

            // --- FIX: New helper functions for direct UI manipulation on settings page ---
            const setDataSourceTab = (type, source) => {
                const isFile = source === 'file';
                UIElements[`${type}TabFile`].classList.toggle('active', isFile);
                UIElements[`${type}TabUrl`].classList.toggle('active', !isFile);
                UIElements[`${type}ContentFile`].classList.toggle('hidden', !isFile);
                UIElements[`${type}ContentUrl`].classList.toggle('hidden', isFile);
            };

            const updateCustomUrlVisibility = (type) => {
                const selectEl = UIElements[`${type}UrlSelect`];
                const customContainer = UIElements[`${type}CustomContainer`];
                const isCustom = selectEl.value === 'custom';
                customContainer.classList.toggle('hidden', !isCustom);
            };
            
            // --- Main Application Logic ---
            const setButtonLoadingState = (isLoading) => {
                UIElements.loadGuideBtn.disabled = isLoading;
                UIElements.loadGuideBtnContent.innerHTML = isLoading ?
                    `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span>Loading...</span>` :
                    `<svg class="w-5 h-5 inline-block -mt-1 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg><span>Load Guide & View</span>`;
            };

            const handleGuideLoad = (m3uContent, epgContent) => new Promise((resolve, reject) => {
                if (!worker) return reject("Worker not initialized!");
                if (!m3uContent) {
                    guideState.channels = [];
                    guideState.programs = {};
                    finalizeGuideLoad();
                    return resolve();
                }
                let m3uParsed = false;
                let epgParsed = !epgContent;
                const checkCompletion = () => {
                    if (m3uParsed && epgParsed) { finalizeGuideLoad(); resolve(); worker.onmessage = null; }
                };
                worker.onmessage = ({ data: { type, data, error } }) => {
                    if (error) { reject(new Error(error)); worker.onmessage = null; return; }
                    if (type === 'm3u-success') {
                        guideState.channels = data;
                        (guideState.settings.favorites || []).forEach(favId => {
                            const channel = guideState.channels.find(c => c.id === favId);
                            if (channel) channel.isFavorite = true;
                        });
                        m3uParsed = true;
                    } else if (type === 'epg-success') {
                        guideState.programs = data;
                        epgParsed = true;
                    }
                    checkCompletion();
                };
                guideState.programs = {};
                worker.postMessage({ type: 'm3u', data: m3uContent });
                if (!epgParsed) {
                    worker.postMessage({ type: 'epg', data: epgContent, timezoneOffset: guideState.settings.timezoneOffset });
                }
            });

            const finalizeGuideLoad = () => {
                guideState.channelGroups.clear();
                guideState.channels.forEach(ch => { if(ch.group) guideState.channelGroups.add(ch.group) });
                populateGroupFilter();
                renderGuide();
            };
            
            const populateGroupFilter = () => {
                UIElements.groupFilter.innerHTML = `<option value="all">All Groups</option><option value="recents">Recents</option><option value="favorites">Favorites</option>`;
                [...guideState.channelGroups].sort((a, b) => a.localeCompare(b)).forEach(group => {
                    UIElements.groupFilter.innerHTML += `<option value="${group}">${group}</option>`;
                });
                UIElements.groupFilter.classList.remove('hidden');
            };

            const renderGuide = (channelsToRender = guideState.channels, resetScroll = true) => {
                const showPlaceholder = channelsToRender.length === 0;
                UIElements.guidePlaceholder.classList.toggle('hidden', !showPlaceholder);
                ['channelPanelContainer', 'resizer', 'logoColumn', 'timelineContainer'].forEach(id => UIElements[id].classList.toggle('hidden', showPlaceholder));
                if (showPlaceholder) return;
                
                const currentScrollTop = UIElements.channelList.scrollTop;
                ['channelList', 'logoList', 'guideTimeline', 'timeBar'].forEach(id => UIElements[id].innerHTML = '');
                UIElements.guideTimeline.innerHTML = '<div id="now-line" class="absolute top-0 bottom-0 bg-red-500 w-0.5 z-20 hidden"></div>';
                
                UIElements.guideDateDisplay.textContent = guideState.currentDate.toLocaleDateString([], { weekday: 'short', month: 'long', day: 'numeric' });
                const timeBarContent = document.createElement('div');
                timeBarContent.className = 'relative h-full';
                timeBarContent.style.width = `${guideState.guideDurationHours * guideState.hourWidthPixels}px`;
                const guideStart = new Date(guideState.currentDate);
                guideStart.setHours(0, 0, 0, 0);
                for (let i = 0; i < guideState.guideDurationHours; i++) {
                    const time = new Date(guideStart); time.setHours(guideStart.getHours() + i);
                    timeBarContent.innerHTML += `<div class="absolute top-0 bottom-0 flex items-center justify-start px-2 text-xs text-gray-400 border-r border-gray-700/50" style="left: ${i * guideState.hourWidthPixels}px; width: ${guideState.hourWidthPixels}px;">${time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>`;
                }
                UIElements.timeBar.appendChild(timeBarContent);
                
                const now = new Date();
                const guideEnd = new Date(guideStart.getTime() + guideState.guideDurationHours * 3600 * 1000);
                let channelRowsHTML = '';
                channelsToRender.forEach(channel => {
                    UIElements.channelList.innerHTML += `<div class="h-20 flex items-center justify-between p-2 border-b border-gray-700/50 flex-shrink-0"><div class="flex items-center overflow-hidden cursor-pointer flex-grow min-w-0" data-url="${channel.url}" data-name="${channel.displayName || channel.name}" data-id="${channel.id}"><img src="${channel.logo}" onerror="this.onerror=null; this.src='https://placehold.co/48x48/1f2937/d1d5db?text=?';" class="w-12 h-12 object-contain mr-3 flex-shrink-0 rounded-md bg-gray-700"><span class="font-semibold text-sm truncate">${channel.displayName || channel.name}</span></div><svg data-channel-id="${channel.id}" class="w-6 h-6 text-gray-500 hover:text-yellow-400 favorite-star cursor-pointer flex-shrink-0 ml-2 ${channel.isFavorite ? 'favorited' : ''}" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path></svg></div>`;
                    UIElements.logoList.innerHTML += `<div class="h-20 flex items-center justify-center p-1 border-b border-gray-700/50 flex-shrink-0 cursor-pointer" data-url="${channel.url}" data-name="${channel.displayName || channel.name}" data-id="${channel.id}"><img src="${channel.logo}" onerror="this.onerror=null; this.src='https://placehold.co/48x48/1f2937/d1d5db?text=?';" class="w-14 h-14 object-contain pointer-events-none"></div>`;
                    let programsHTML = '';
                    (guideState.programs[channel.id] || []).forEach(prog => {
                        const progStart = new Date(prog.start);
                        const progStop = new Date(prog.stop);
                        if (progStop < guideStart || progStart > guideEnd) return;
                        const durationMs = progStop - progStart;
                        if (durationMs <= 0) return;
                        const left = ((progStart - guideStart) / 3600000) * guideState.hourWidthPixels;
                        const width = (durationMs / 3600000) * guideState.hourWidthPixels;
                        const isLive = now > progStart && now < progStop;
                        const progressWidth = isLive ? ((now - progStart) / durationMs) * 100 : 0;
                        programsHTML += `<div class="programme-item absolute top-1 bottom-1 bg-gray-800 rounded-md p-2 overflow-hidden flex flex-col justify-center z-5 ${isLive ? 'live' : ''} ${progStop < now ? 'past' : ''}" style="left:${left}px; width:${Math.max(0, width - 2)}px" data-channel-url="${channel.url}" data-channel-id="${channel.id}" data-channel-name="${channel.name}" data-prog-title="${prog.title}" data-prog-desc="${prog.desc}" data-prog-start="${progStart.toISOString()}" data-prog-stop="${progStop.toISOString()}"><div class="programme-progress" style="width:${progressWidth}%"></div><p class="prog-title text-white font-semibold truncate relative z-10">${prog.title}</p><p class="prog-time text-gray-400 truncate relative z-10">${progStart.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})} - ${progStop.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</p></div>`;
                    });
                    channelRowsHTML += `<div class="h-20 border-b border-gray-700/50 relative">${programsHTML}</div>`;
                });
                UIElements.guideTimeline.insertAdjacentHTML('beforeend', channelRowsHTML);
                
                const totalGuideHeight = channelsToRender.length * 80;
                setTimeout(() => {
                    UIElements.channelList.scrollTop = resetScroll ? 0 : currentScrollTop;
                    UIElements.guideTimeline.scrollTop = UIElements.channelList.scrollTop;
                    UIElements.logoList.scrollTop = UIElements.channelList.scrollTop;
                    updateNowLine(guideStart, resetScroll, totalGuideHeight);
                }, 0);
            };

            const updateNowLine = (guideStart, shouldScroll, totalGuideHeight) => {
                const nowLineEl = document.getElementById('now-line');
                if (!nowLineEl) return;
                nowLineEl.style.height = `${totalGuideHeight}px`;
                const now = new Date();
                const guideEnd = new Date(guideStart.getTime() + guideState.guideDurationHours * 3600 * 1000);
                if (now >= guideStart && now <= guideEnd) {
                    const left = ((now - guideStart) / 3600000) * guideState.hourWidthPixels;
                    nowLineEl.style.left = `${left}px`;
                    nowLineEl.classList.remove('hidden');
                    if (shouldScroll) UIElements.guideTimeline.scrollLeft = left - (UIElements.guideTimeline.clientWidth / 4);
                } else {
                    nowLineEl.classList.add('hidden');
                }
                document.querySelectorAll('.programme-item.live .programme-progress').forEach(el => {
                    const item = el.parentElement;
                    const progStart = new Date(item.dataset.progStart);
                    const progStop = new Date(item.dataset.progStop);
                    const durationMs = progStop - progStart;
                    const elapsedMs = now - progStart;
                    el.style.width = `${(elapsedMs / durationMs) * 100}%`;
                });
                setTimeout(() => updateNowLine(guideStart, false, totalGuideHeight), 60000);
            };

            const stopAndCleanupPlayer = () => {
                if (player) { player.destroy(); player = null; }
                UIElements.videoElement.src = "";
                UIElements.videoElement.removeAttribute('src');
                UIElements.videoElement.load();
                if (document.pictureInPictureElement) document.exitPictureInPicture().catch(console.error);
                closeModal(UIElements.videoModal);
            };

            const playChannel = async (url, name, channelId) => {
                if (player) stopAndCleanupPlayer();
                if(channelId) {
                    guideState.settings.recentChannels = [channelId, ...(guideState.settings.recentChannels || []).filter(id => id !== channelId)].slice(0, 15);
                    await saveSettings();
                }
                if (mpegts.isSupported()) {
                    player = mpegts.createPlayer({ type: 'mse', isLive: true, url: `/stream?url=${encodeURIComponent(url)}` });
                    openModal(UIElements.videoModal);
                    UIElements.videoTitle.textContent = name;
                    player.attachMediaElement(UIElements.videoElement);
                    player.load();
                    UIElements.videoElement.volume = parseFloat(localStorage.getItem('iptvPlayerVolume') || 0.5);
                    player.play().catch(() => {
                        showNotification("Could not play stream. Check server logs.", true);
                        stopAndCleanupPlayer();
                    });
                } else {
                    showNotification('Your browser does not support MSE.', true);
                }
            };
            
            const setupAutoRefresh = (hours) => {
                clearInterval(autoRefreshIntervalId);
                if (hours > 0) {
                    autoRefreshIntervalId = setInterval(() => {
                        if (guideState.settings.m3uSourceType === 'url' || guideState.settings.epgSourceType === 'url') {
                            showNotification(`Auto-refreshing guide data...`);
                            UIElements.loadGuideBtn.click();
                        }
                    }, hours * 3600 * 1000);
                }
            };

            const addUrlToSelect = (selectEl, url, makeActive) => {
                if ([...selectEl.options].some(opt => opt.value === url)) {
                    if (makeActive) selectEl.value = url;
                    return;
                }
                const option = document.createElement('option');
                option.value = url;
                option.textContent = url.length > 60 ? url.substring(0, 57) + '...' : url;
                selectEl.insertBefore(option, selectEl.querySelector('option[value="custom"]'));
                if (makeActive) selectEl.value = url;
            };

            const saveCustomUrl = async (type) => {
                const inputEl = UIElements[`${type}UrlInput`];
                const url = inputEl.value.trim();
                if (!url) return showNotification('URL cannot be empty.', true);
                try {
                    new URL(url);
                    const response = await fetch('/api/save/url', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ type, url }),
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.error);
                    
                    guideState.settings = result.settings; // Update local settings with the server's response
                    updateUIFromSettings(); // Re-render the UI based on the new settings
                    showNotification(`${type.toUpperCase()} URL saved and selected.`);

                } catch (e) {
                    showNotification(`Error: ${e.message}`, true);
                }
            };
            
            const handleSearchAndFilter = () => {
                const searchTerm = UIElements.searchInput.value.toLowerCase().trim();
                const selectedGroup = UIElements.groupFilter.value;
                let filteredChannels = guideState.channels;

                if (selectedGroup !== 'all') {
                    if (selectedGroup === 'favorites') {
                        filteredChannels = filteredChannels.filter(ch => ch.isFavorite);
                    } else if (selectedGroup === 'recents') {
                        filteredChannels = (guideState.settings.recentChannels || [])
                            .map(id => guideState.channels.find(ch => ch.id === id))
                            .filter(Boolean); // Filter out undefined if a channel was deleted
                    } else {
                        filteredChannels = filteredChannels.filter(ch => ch.group === selectedGroup);
                    }
                }
                
                UIElements.searchResultsContainer.innerHTML = '';

                if (searchTerm) {
                    const matchingChannels = filteredChannels.filter(ch => (ch.displayName || ch.name).toLowerCase().includes(searchTerm));
                    renderGuide(matchingChannels, false);

                    const programResults = [];
                    const guideStart = new Date(guideState.currentDate);
                    guideStart.setHours(0, 0, 0, 0);
                    const guideEnd = new Date(guideStart.getTime() + guideState.guideDurationHours * 3600 * 1000);

                    for (const channel of guideState.channels) {
                        for (const prog of (guideState.programs[channel.id] || [])) {
                             const progStart = new Date(prog.start);
                             const progStop = new Date(prog.stop);
                            if (progStop < guideStart || progStart > guideEnd) continue;
                            if (prog.title.toLowerCase().includes(searchTerm)) {
                                programResults.push({ channel, program: prog });
                                if (programResults.length >= 50) break;
                            }
                        }
                        if (programResults.length >= 50) break;
                    }

                    if (programResults.length > 0) {
                        UIElements.searchResultsContainer.innerHTML = `<div class="p-2 bg-gray-700 text-xs font-bold text-gray-400">PROGRAM RESULTS</div>` +
                        programResults.map(({ channel, program }) => `
                            <div class="search-result-program p-3 border-b border-gray-700 hover:bg-gray-700 cursor-pointer" data-channel-id="${channel.id}" data-prog-start="${program.start}">
                                <p class="font-semibold text-white text-sm truncate">${program.title}</p>
                                <p class="text-gray-400 text-xs truncate">${channel.name}</p>
                            </div>
                        `).join('');
                        UIElements.searchResultsContainer.classList.remove('hidden');
                    } else {
                         UIElements.searchResultsContainer.classList.add('hidden');
                    }
                } else {
                    renderGuide(filteredChannels, false);
                    UIElements.searchResultsContainer.classList.add('hidden');
                }
            };
            
            const populateTimezoneSelector = () => {
                UIElements.timezoneOffsetSelect.innerHTML = '';
                for (let i = 14; i >= -12; i--) {
                    UIElements.timezoneOffsetSelect.innerHTML += `<option value="${i}">UTC${i >= 0 ? '+' : ''}${i}:00</option>`;
                }
            };

            // --- Event Listeners ---
            function setupEventListeners() {
                // Main Navigation
                ['tabGuide', 'bottomNavGuide'].forEach(id => UIElements[id].addEventListener('click', () => switchTab('guide')));
                ['tabSettings', 'bottomNavSettings'].forEach(id => UIElements[id].addEventListener('click', () => switchTab('settings')));

                // Modals & Confirmations
                UIElements.confirmCancelBtn.addEventListener('click', () => closeModal(UIElements.confirmModal));
                UIElements.confirmOkBtn.addEventListener('click', () => { if (confirmCallback) confirmCallback(); closeModal(UIElements.confirmModal); });
                UIElements.detailsCloseBtn.addEventListener('click', () => closeModal(UIElements.programDetailsModal));
                UIElements.closeModal.addEventListener('click', () => document.pictureInPictureElement ? closeModal(UIElements.videoModal) : stopAndCleanupPlayer());
                UIElements.pipBtn.addEventListener('click', () => {
                    if(document.pictureInPictureEnabled && UIElements.videoElement.readyState === 4) {
                        UIElements.videoElement.requestPictureInPicture().catch(console.error);
                    }
                });
                UIElements.videoElement.addEventListener('leavepictureinpicture', stopAndCleanupPlayer);
                UIElements.videoElement.addEventListener('volumechange', () => localStorage.setItem('iptvPlayerVolume', UIElements.videoElement.volume));

                // Guide Interaction
                UIElements.sidebarToggle.addEventListener('click', () => toggleSidebar(true));
                UIElements.sidebarOverlay.addEventListener('click', () => toggleSidebar(false));
                UIElements.channelList.addEventListener('click', async (e) => {
                    const favoriteStar = e.target.closest('.favorite-star');
                    if (favoriteStar) {
                        const channelId = favoriteStar.dataset.channelId;
                        const channel = guideState.channels.find(c => c.id === channelId);
                        if (!channel) return;
                        channel.isFavorite = !channel.isFavorite;
                        favoriteStar.classList.toggle('favorited', channel.isFavorite);
                        guideState.settings.favorites = guideState.channels.filter(c => c.isFavorite).map(c => c.id);
                        await saveSettings();
                        if (UIElements.groupFilter.value === 'favorites') handleSearchAndFilter();
                        return;
                    }
                    const channelItem = e.target.closest('div[data-url]');
                    if (channelItem) {
                        playChannel(channelItem.dataset.url, channelItem.dataset.name, channelItem.dataset.id);
                        if (window.innerWidth < 1024) toggleSidebar(false);
                    }
                });
                
                UIElements.guideTimeline.addEventListener('click', (e) => {
                    const progItem = e.target.closest('.programme-item');
                    if (!progItem) return;
                    UIElements.detailsTitle.textContent = progItem.dataset.progTitle;
                    const progStart = new Date(progItem.dataset.progStart);
                    const progStop = new Date(progItem.dataset.progStop);
                    UIElements.detailsTime.textContent = `${progStart.toLocaleTimeString([],{hour:'2-digit', minute:'2-digit'})} - ${progStop.toLocaleTimeString([],{hour:'2-digit', minute:'2-digit'})}`;
                    UIElements.detailsDesc.textContent = progItem.dataset.progDesc || "No description available.";
                    UIElements.detailsPlayBtn.onclick = () => {
                        playChannel(progItem.dataset.channelUrl, `${progItem.dataset.channelName} - ${progItem.dataset.progTitle}`, progItem.dataset.channelId);
                        closeModal(UIElements.programDetailsModal);
                    };
                    openModal(UIElements.programDetailsModal);
                });
                
                UIElements.searchResultsContainer.addEventListener('click', e => {
                    const progItemData = e.target.closest('.search-result-program');
                    if (progItemData) {
                        const progStart = new Date(progItemData.dataset.progStart);
                        guideState.currentDate = progStart;
                        renderGuide(guideState.channels, false); 
                        setTimeout(() => {
                            const guideStartTime = new Date(guideState.currentDate);
                            guideStartTime.setHours(0,0,0,0);
                            const channelIndex = guideState.channels.findIndex(ch => ch.id === progItemData.dataset.channelId);
                            if (channelIndex === -1) return;
                            const hScroll = ((progStart - guideStartTime) / 3600000) * guideState.hourWidthPixels;
                            UIElements.guideTimeline.scrollTo({ top: channelIndex * 80, left: hScroll - (UIElements.guideTimeline.clientWidth / 4), behavior: 'smooth' });
                        }, 150);
                        UIElements.searchResultsContainer.classList.add('hidden');
                        UIElements.searchInput.value = '';
                    }
                });

                // Guide Navigation
                UIElements.prevDayBtn.addEventListener('click', () => { guideState.currentDate.setDate(guideState.currentDate.getDate() - 1); renderGuide(undefined, false); });
                UIElements.todayBtn.addEventListener('click', () => { guideState.currentDate = new Date(); renderGuide(); });
                UIElements.nowBtn.addEventListener('click', () => {
                    const now = new Date();
                    if (guideState.currentDate.toDateString() !== now.toDateString()) {
                        guideState.currentDate = now;
                        renderGuide(); // will auto-scroll
                    } else {
                        const guideStart = new Date(guideState.currentDate); guideStart.setHours(0,0,0,0);
                        UIElements.guideTimeline.scrollTo({ left: ((now - guideStart) / 3600000) * guideState.hourWidthPixels - (UIElements.guideTimeline.clientWidth / 4), behavior: 'smooth' });
                    }
                });
                UIElements.nextDayBtn.addEventListener('click', () => { guideState.currentDate.setDate(guideState.currentDate.getDate() + 1); renderGuide(undefined, false); });

                // --- FIX: Re-written Settings Page Listeners ---
                ['m3u', 'epg'].forEach(type => {
                    // Event listener for the "From File" tab button.
                    UIElements[`${type}TabFile`].addEventListener('click', () => {
                        setDataSourceTab(type, 'file'); // Directly update the UI
                        guideState.settings[`${type}SourceType`] = 'file'; // Update state
                        saveSettings(); // Save state to server in the background
                    });

                    // Event listener for the "From URL" tab button.
                    UIElements[`${type}TabUrl`].addEventListener('click', () => {
                        setDataSourceTab(type, 'url'); // Directly update the UI
                        guideState.settings[`${type}SourceType`] = 'url'; // Update state
                        saveSettings(); // Save state to server in the background
                    });

                    // Event listener for the URL dropdown selection.
                    UIElements[`${type}UrlSelect`].addEventListener('change', () => {
                        updateCustomUrlVisibility(type); // Show/hide custom input
                        const selectedUrl = UIElements[`${type}UrlSelect`].value;
                        if (selectedUrl !== 'custom') {
                            guideState.settings[`${type}Url`] = selectedUrl;
                            UIElements[`${type}UrlInput`].value = selectedUrl;
                        } else {
                            // If user selects "Custom URL...", clear the setting
                            guideState.settings[`${type}Url`] = '';
                            UIElements[`${type}UrlInput`].value = '';
                        }
                        saveSettings(); // Save the change
                    });

                    // Event listener for the "Save" button for custom URLs.
                    UIElements[`save${type.charAt(0).toUpperCase() + type.slice(1)}UrlBtn`].addEventListener('click', () => saveCustomUrl(type));
                });
                
                UIElements.loadGuideBtn.addEventListener('click', async () => {
                    setButtonLoadingState(true);
                    try {
                        const { m3uSourceType, epgSourceType } = guideState.settings;
                        
                        // Handle File Uploads first
                        if (m3uSourceType === 'file' || epgSourceType === 'file') {
                            const formData = new FormData();
                            const m3uFile = UIElements.m3uUpload.files[0];
                            const epgFile = UIElements.epgUpload.files[0];
                            if (m3uSourceType === 'file' && m3uFile) formData.append('m3u-file', m3uFile);
                            if (epgSourceType === 'file' && epgFile) formData.append('epg-file', epgFile);
                            
                            if (formData.has('m3u-file') || formData.has('epg-file')) {
                                const res = await fetch('/api/upload', { method: 'POST', body: formData });
                                if (!res.ok) throw new Error('File upload failed on server.');
                            }
                        }

                        // --- FIX: Await the URL fetches ---
                        if (m3uSourceType === 'url') {
                            const url = UIElements.m3uUrlInput.value.trim();
                            if (url) {
                                const res = await fetch(`/fetch-m3u?url=${encodeURIComponent(url)}`);
                                if (!res.ok) throw new Error(`M3U Fetch Failed: ${await res.text()}`);
                            }
                        }
                        if (epgSourceType === 'url') {
                            const url = UIElements.epgUrlInput.value.trim();
                            if (url) {
                                const res = await fetch(`/fetch-epg?url=${encodeURIComponent(url)}`);
                                if (!res.ok) throw new Error(`EPG Fetch Failed: ${await res.text()}`);
                            }
                        }
                        
                        // After all actions, get the final state from the server
                        const configResponse = await fetch('/api/config');
                        const config = await configResponse.json();
                        if (!configResponse.ok) throw new Error('Could not retrieve config from server.');
                        
                        if (!config.m3uContent) {
                            throw new Error("No M3U data found on server. Please select a valid source.");
                        }

                        await handleGuideLoad(config.m3uContent, config.epgContent);
                        guideState.settings = config.settings || {}; // Sync local state with server
                        updateUIFromSettings();
                        switchTab('guide');
                        showNotification('Guide data loaded successfully!');

                    } catch (error) {
                        showNotification(`Error: ${error.message}`, true);
                    } finally {
                        setButtonLoadingState(false);
                    }
                });

                UIElements.clearDataBtn.addEventListener('click', () => {
                    showConfirm('Clear All Data?', 'This will permanently delete ALL settings and files from the server. The page will reload.', async () => {
                        try {
                            const res = await fetch('/api/data', { method: 'DELETE' });
                            if (!res.ok) throw new Error('Failed to clear data on server.');
                            showNotification('All data cleared. Reloading...');
                            setTimeout(() => window.location.reload(), 1500);
                        } catch (e) { showNotification(e.message, true); }
                    });
                });
                
                UIElements.autoRefreshSelect.addEventListener('change', async (e) => { guideState.settings.autoRefresh = parseInt(e.target.value, 10); await saveSettings(); setupAutoRefresh(guideState.settings.autoRefresh); });
                UIElements.timezoneOffsetSelect.addEventListener('change', async (e) => { guideState.settings.timezoneOffset = parseInt(e.target.value, 10); await saveSettings(); showNotification(`Timezone offset set. Reload guide to apply.`); });
                UIElements.searchInput.addEventListener('input', () => { clearTimeout(searchDebounceTimer); searchDebounceTimer = setTimeout(handleSearchAndFilter, 300); });
                document.addEventListener('click', e => { if (!UIElements.searchInput.contains(e.target) && !UIElements.searchResultsContainer.contains(e.target)) UIElements.searchResultsContainer.classList.add('hidden'); });

                // Synced Scrolling
                let ignoreScroll = false;
                const syncScroll = (source, targets) => {
                    if (ignoreScroll) { ignoreScroll = false; return; }
                    ignoreScroll = true;
                    targets.forEach(target => { if (target) target.scrollTop = source.scrollTop; });
                };
                UIElements.guideTimeline.addEventListener('scroll', (e) => {
                    UIElements.timeBar.scrollLeft = e.target.scrollLeft;
                    syncScroll(e.target, [UIElements.channelList, UIElements.logoList]);
                });
                UIElements.channelList.addEventListener('scroll', (e) => syncScroll(e.target, [UIElements.guideTimeline, UIElements.logoList]));
                UIElements.logoList.addEventListener('scroll', (e) => syncScroll(e.target, [UIElements.guideTimeline, UIElements.channelList]));

                // Panel Resizing
                UIElements.resizer.addEventListener('mousedown', e => {
                    e.preventDefault();
                    const startX = e.clientX, startWidth = UIElements.channelPanelContainer.offsetWidth;
                    const doResize = (e) => UIElements.channelPanelContainer.style.width = `${Math.max(250, startWidth + e.clientX - startX)}px`;
                    const stopResize = () => { window.removeEventListener('mousemove', doResize); window.removeEventListener('mouseup', stopResize); };
                    window.addEventListener('mousemove', doResize);
                    window.addEventListener('mouseup', stopResize);
                }, false);
            }

            // --- Initialization ---
            // --- FIX: Re-written function to safely set initial UI state from settings ---
            const updateUIFromSettings = () => {
                const settings = guideState.settings;
                settings.timezoneOffset = settings.timezoneOffset ?? Math.round(-(new Date().getTimezoneOffset() / 60));
                UIElements.timezoneOffsetSelect.value = settings.timezoneOffset;
                settings.autoRefresh = settings.autoRefresh || 0;
                UIElements.autoRefreshSelect.value = settings.autoRefresh;
                setupAutoRefresh(settings.autoRefresh);
                
                ['m3u', 'epg'].forEach(type => {
                    const sourceType = settings[`${type}SourceType`] || 'url';
                    setDataSourceTab(type, sourceType);
                    
                    const selectEl = UIElements[`${type}UrlSelect`];
                    selectEl.innerHTML = '<option value="custom">Custom URL...</option>';
                    const customUrls = settings[`${type}CustomUrls`] || [];
                    customUrls.forEach(url => addUrlToSelect(selectEl, url, false));
                    
                    const activeUrl = settings[`${type}Url`];
                    
                    if (activeUrl && customUrls.includes(activeUrl)) {
                        selectEl.value = activeUrl;
                    } else {
                        selectEl.value = 'custom';
                    }

                    UIElements[`${type}UrlInput`].value = activeUrl || '';
                    
                    updateCustomUrlVisibility(type);
                });
            };

            const initApp = async () => {
                const blob = new Blob([document.querySelector('#parser-worker').textContent], { type: 'text/javascript' });
                worker = new Worker(window.URL.createObjectURL(blob));
                populateTimezoneSelector();
                try {
                    const response = await fetch('/api/config');
                    if (!response.ok) throw new Error('Could not connect to the server.');
                    const config = await response.json();
                    guideState.settings = config.settings || { favorites:[], recentChannels:[], m3uCustomUrls:[], epgCustomUrls:[], m3uSourceType: 'url', epgSourceType: 'url'};
                    updateUIFromSettings();
                    if (config.m3uContent) {
                        showNotification("Loading guide from server...", false, 1500);
                        setButtonLoadingState(true);
                        await handleGuideLoad(config.m3uContent, config.epgContent);
                        switchTab('guide');
                        setButtonLoadingState(false);
                    } else {
                        switchTab('settings');
                        renderGuide([]); // Render an empty guide to show the placeholder
                    }
                } catch (e) {
                    showNotification("Initialization failed: " + e.message, true);
                    switchTab('settings');
                }
                setupEventListeners();
            };
            
            initApp();
        });
    </script>
</body>
</html>
