<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VINI PLAY</title>
    <link rel="icon" type="image/png" href="https://i.imgur.com/rwa8SjI.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/mpegts.js/dist/mpegts.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* gray-900 */
            color: #d1d5db; /* gray-300 */
        }
        .custom-scrollbar::-webkit-scrollbar { height: 8px; width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1f2937; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        .tab-button.active { background-color: #3b82f6; color: white; }
        .bottom-nav-btn.active { color: #3b82f6; }
        .data-tab-button.active { color: #3b82f6; font-weight: 600; border-bottom-color: #3b82f6; }
        .programme-item { border-left: 3px solid #3b82f6; transition: background-color 0.3s, border-color 0.3s, opacity 0.3s; }
        .programme-item:hover { background-color: #374151; cursor: pointer; }
        html, body { height: 100%; overflow: hidden; }
        .favorite-star { transition: color 0.2s, transform 0.2s; }
        .favorite-star.favorited { color: #facc15; transform: scale(1.2); }
        .programme-progress { position: absolute; top: 0; left: 0; bottom: 0; background-color: rgba(59, 130, 246, 0.3); border-radius: 2px 0 0 2px; pointer-events: none; transition: width 0.3s linear; }
        .programme-item.past { background-color: #374151; border-left-color: #6b7280; opacity: 0.6; }
        .programme-item.live { border-left: 4px solid #fb923c; background-color: #374151; }
        .programme-item.live::after { content: 'LIVE'; position: absolute; top: 4px; right: 4px; background-color: #ef4444; color: white; padding: 1px 4px; font-size: 0.65rem; font-weight: 700; border-radius: 4px; z-index: 20; }
        .programme-item .prog-title { font-size: 0.9rem; font-weight: 600; }
        .programme-item .prog-time { font-size: 0.75rem; }
        #group-filter, #search-input, #timezone-offset-select { transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease; }
        #group-filter:hover, #search-input:hover, #timezone-offset-select:hover { background-color: #4b5563; }
        #channel-panel-container { transition: transform 0.3s ease-in-out; }
        #sidebar-overlay { transition: opacity 0.3s ease-in-out; }
        body.modal-open { overflow: hidden; }
        .programme-item.highlighted { outline: 3px solid #facc15; z-index: 15; transition: outline 0.2s ease-in-out; }
        button:disabled { cursor: not-allowed; background-color: #4b5563; opacity: 0.7; }
        #editor-value:disabled { background-color: #374151; color: #9ca3af; }
        /* NEW: Loading spinner style */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="flex flex-col h-screen">

    <!-- Header -->
    <header class="bg-gray-800 text-white p-4 shadow-md z-30 flex-shrink-0 flex items-center justify-between">
        <div class="flex items-center gap-3">
            <img src="https://i.imgur.com/rwa8SjI.png" alt="VINI PLAY Logo" class="h-8 w-8">
            <h1 class="text-xl sm:text-2xl font-bold">VINI PLAY</h1>
        </div>
        <button id="sidebar-toggle" class="lg:hidden p-2 rounded-md hover:bg-gray-700">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>
        </button>
    </header>

    <!-- Desktop Tabs -->
    <div class="hidden lg:flex border-b border-gray-700 bg-gray-800 flex-shrink-0 z-20">
        <button id="tab-guide" class="tab-button text-sm sm:text-base font-medium py-3 px-6 text-gray-300 hover:bg-gray-700 active">TV Guide</button>
        <button id="tab-settings" class="tab-button text-sm sm:text-base font-medium py-3 px-6 text-gray-300 hover:bg-gray-700">Settings</button>
    </div>

    <!-- Main Content -->
    <main class="flex-grow flex flex-col overflow-hidden">
        <!-- TV Guide Page -->
        <div id="page-guide" class="flex flex-grow flex-col overflow-hidden">
            <div class="flex flex-wrap items-center justify-between gap-4 p-2 sm:p-4 border-b border-gray-700 flex-shrink-0">
                <div class="flex items-center gap-2">
                    <button id="prev-day-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-3 rounded-md text-sm transition-colors">&lt;</button>
                    <button id="now-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md text-sm transition-colors">Now</button>
                    <button id="next-day-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-3 rounded-md text-sm transition-colors">&gt;</button>
                </div>
                <div id="guide-date-display" class="text-base sm:text-lg font-semibold text-center flex-grow"></div>
                <div class="relative w-full sm:w-auto flex items-center gap-2">
                    <input type="search" id="search-input" placeholder="Search channels & programs..." class="w-full sm:w-64 bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-sm text-white focus:ring-blue-500 focus:border-blue-500">
                    <button id="today-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-3 rounded-md text-sm transition-colors flex-shrink-0">Reset view</button>
                    <div id="search-results-container" class="hidden absolute top-full right-0 w-full sm:w-96 max-h-80 overflow-y-auto bg-gray-800 border border-gray-600 rounded-md mt-1 z-50 custom-scrollbar shadow-lg"></div>
                </div>
            </div>
            <div id="guide-container" class="flex-grow flex bg-gray-900 overflow-hidden relative">
                <!-- MODIFIED: Placeholder and Loading Indicator -->
                <div id="guide-placeholder" class="absolute inset-0 flex items-center justify-center z-40">
                    <div id="initial-loading-indicator" class="text-center text-gray-400">
                        <div class="loader mx-auto"></div>
                        <p class="mt-4">Loading application...</p>
                    </div>
                    <div id="no-data-message" class="hidden text-center text-gray-500 p-4">
                        <svg class="mx-auto h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
                        <h3 class="mt-2 text-sm font-medium">No Data Loaded</h3>
                        <p class="mt-1 text-sm">Go to the Settings tab to load your M3U and EPG files.</p>
                    </div>
                </div>
                <div id="sidebar-overlay" class="fixed inset-0 bg-black/50 z-40 hidden lg:hidden"></div>
                <div id="channel-panel-container" class="absolute lg:relative inset-y-0 left-0 w-64 sm:w-80 bg-gray-800/80 lg:bg-gray-800 backdrop-blur-sm lg:backdrop-blur-none z-50 transform -translate-x-full lg:transform-none lg:translate-x-0 min-w-[250px] max-w-[80vw] lg:max-w-[30vw] flex-shrink-0 flex flex-col hidden lg:flex">
                    <div class="h-16 flex items-center justify-between p-2 border-b border-gray-700/80 flex-shrink-0">
                         <select id="group-filter" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500 hidden"></select>
                    </div>
                    <div id="channel-list" class="overflow-y-auto custom-scrollbar flex-grow"></div>
                </div>
                <div id="resizer" class="hidden lg:block w-1.5 cursor-col-resize bg-gray-700 hover:bg-blue-500 z-10"></div>
                <div id="logo-column" class="flex flex-col lg:hidden w-20 flex-shrink-0 bg-gray-900 border-r border-gray-700/50">
                    <div class="h-16 flex-shrink-0 border-b border-gray-700/80"></div>
                    <div id="logo-list" class="overflow-y-auto custom-scrollbar flex-grow"></div>
                </div>
                <div id="timeline-container" class="flex-grow flex flex-col overflow-hidden">
                    <div id="time-bar" class="h-16 bg-gray-800/80 flex-shrink-0 relative z-10 overflow-x-hidden"></div>
                    <div id="guide-timeline" class="overflow-auto custom-scrollbar relative flex-grow">
                        <div id="now-line" class="absolute top-0 bottom-0 bg-red-500 w-0.5 z-20 hidden"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Settings Page -->
        <div id="page-settings" class="hidden flex-grow flex-col items-center p-4 overflow-y-auto custom-scrollbar">
            <div class="w-full max-w-4xl mx-auto space-y-8 pb-16">
                <!-- Guide Data Section -->
                <div class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold text-white mb-4 border-b border-gray-700 pb-2">Load Guide Data</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-8">
                        <div>
                            <label class="block text-sm font-medium text-gray-400 mb-2">1. M3U Source</label>
                            <div class="flex border-b border-gray-600">
                                <button id="m3u-tab-file" class="data-tab-button flex-1 py-2 text-sm">From File</button>
                                <button id="m3u-tab-url" class="data-tab-button active flex-1 py-2 text-sm">From URL</button>
                            </div>
                            <div id="m3u-content-file" class="hidden mt-4"><input type="file" id="m3u-upload" name="m3u-file" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600 cursor-pointer"></div>
                            <div id="m3u-content-url" class="mt-4">
                                <div class="space-y-2">
                                    <select id="m3u-url-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500">
                                        <option value="custom">Custom URL...</option>
                                    </select>
                                    <div id="m3u-custom-container" class="hidden flex gap-2 mt-2">
                                        <input type="url" id="m3u-url-input" placeholder="Enter custom M3U URL..." class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500">
                                        <button id="save-m3u-url-btn" title="Save URL to list" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md flex-shrink-0">Save</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-400 mb-2">2. EPG Source (Optional)</label>
                            <div class="flex border-b border-gray-600">
                                <button id="epg-tab-file" class="data-tab-button flex-1 py-2 text-sm">From File</button>
                                <button id="epg-tab-url" class="data-tab-button active flex-1 py-2 text-sm">From URL</button>
                            </div>
                            <div id="epg-content-file" class="hidden mt-4"><input type="file" id="epg-upload" name="epg-file" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-500 file:text-white hover:file:bg-blue-600 cursor-pointer"></div>
                            <div id="epg-content-url" class="mt-4">
                                <div class="space-y-2">
                                    <select id="epg-url-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500">
                                        <option value="custom">Custom URL...</option>
                                    </select>
                                    <div id="epg-custom-container" class="hidden flex gap-2 mt-2">
                                        <input type="url" id="epg-url-input" placeholder="Enter custom EPG URL..." class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500">
                                        <button id="save-epg-url-btn" title="Save URL to list" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-3 rounded-md flex-shrink-0">Save</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="md:col-span-2">
                            <button id="load-guide-btn" class="w-full bg-green-600 hover:bg-green-700 disabled:bg-green-800 disabled:cursor-not-allowed text-white font-bold py-3 px-4 rounded-md transition-colors flex items-center justify-center gap-2">
                                <span id="load-guide-btn-content">
                                    <svg class="w-5 h-5 inline-block -mt-1 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                                    <span>Load Guide & View</span>
                                </span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Player Settings Section -->
                <div class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold text-white mb-4 border-b border-gray-700 pb-2">Player Settings</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-8">
                        <!-- User Agents Section -->
                        <div>
                            <label for="user-agent-select" class="block text-sm font-medium text-gray-400 mb-2">Active User Agent</label>
                            <select id="user-agent-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500 mb-2"></select>
                            <div class="flex gap-2">
                                <button id="add-user-agent-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white text-sm font-bold py-2 px-4 rounded-md">New</button>
                                <button id="edit-user-agent-btn" class="flex-1 bg-gray-600 hover:bg-gray-500 text-white text-sm font-bold py-2 px-4 rounded-md">Edit</button>
                                <button id="delete-user-agent-btn" class="flex-1 bg-red-600 hover:bg-red-700 text-white text-sm font-bold py-2 px-4 rounded-md">Delete</button>
                            </div>
                        </div>
                        <!-- Stream Profiles Section -->
                        <div>
                            <label for="stream-profile-select" class="block text-sm font-medium text-gray-400 mb-2">Active Stream Profile</label>
                            <select id="stream-profile-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500 mb-2"></select>
                            <div class="flex gap-2">
                                <button id="add-stream-profile-btn" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white text-sm font-bold py-2 px-4 rounded-md">New</button>
                                <button id="edit-stream-profile-btn" class="flex-1 bg-gray-600 hover:bg-gray-500 text-white text-sm font-bold py-2 px-4 rounded-md">Edit</button>
                                <button id="delete-stream-profile-btn" class="flex-1 bg-red-600 hover:bg-red-700 text-white text-sm font-bold py-2 px-4 rounded-md">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- App Settings Section -->
                <div class="bg-gray-800 p-4 sm:p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold text-white mb-4 border-b border-gray-700 pb-2">App Settings</h2>
                    <div class="space-y-4">
                        <div>
                            <label for="auto-refresh-select" class="block text-sm font-medium text-gray-400 mb-1">Auto Refresh URL Data</label>
                            <select id="auto-refresh-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500">
                                <option value="0">Disabled</option>
                                <option value="1">Every 1 Hour</option>
                                <option value="4">Every 4 Hours</option>
                                <option value="12">Every 12 Hours</option>
                                <option value="24">Every 24 Hours</option>
                            </select>
                        </div>
                        <div>
                            <label for="timezone-offset-select" class="block text-sm font-medium text-gray-400 mb-1">EPG Timezone Correction</label>
                             <p class="text-xs text-gray-500 mb-2">Use this if EPG times are wrong. It only affects programs without timezone info.</p>
                            <select id="timezone-offset-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500"></select>
                        </div>
                        <!-- NEW: Search Scope Setting -->
                        <div>
                             <label for="search-scope-select" class="block text-sm font-medium text-gray-400 mb-1">Guide Search Scope</label>
                              <p class="text-xs text-gray-500 mb-2">Control what the search bar in the TV Guide looks for.</p>
                             <select id="search-scope-select" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500">
                                 <option value="channels_programs">Channels & Programs (Default)</option>
                                 <option value="channels_only">Channels Only</option>
                             </select>
                         </div>
                    </div>
                </div>
            
                <!-- Danger Zone -->
                <div class="bg-red-900/50 border border-red-700/50 p-4 sm:p-6 rounded-xl shadow-lg">
                    <h2 class="text-xl font-bold text-red-300 mb-4 border-b border-red-700/50 pb-2">Danger Zone</h2>
                    <p class="text-sm text-gray-400 mb-4">This permanently deletes all saved application data from the server and browser.</p>
                    <button id="clear-data-btn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-md flex items-center justify-center gap-2"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg><span>Clear All Data & Reset</span></button>
                </div>
            </div>
        </div>
    </main>
    
    <!-- Bottom Navigation -->
    <nav class="lg:hidden bg-gray-800 border-t border-gray-700 flex justify-around flex-shrink-0 z-20">
        <button id="bottom-nav-guide" class="bottom-nav-btn flex-1 p-3 text-gray-400 active">
            <svg class="mx-auto h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path></svg>
            <span class="text-xs">Guide</span>
        </button>
        <button id="bottom-nav-settings" class="bottom-nav-btn flex-1 p-3 text-gray-400">
            <svg class="mx-auto h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0 3.35a1.724 1.724 0 001.066 2.573c-.94-1.543.826 3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
            <span class="text-xs">Settings</span>
        </button>
    </nav>

    <!-- Modals -->
    <div id="video-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50">
        <div class="bg-gray-900 rounded-lg shadow-xl w-full max-w-4xl max-h-[90vh] flex flex-col">
            <div class="flex justify-between items-center p-3 border-b border-gray-700">
                <h3 id="video-title" class="text-lg font-semibold text-white truncate"></h3>
                <div class="flex items-center gap-2">
                    <button id="pip-btn" class="text-gray-400 hover:text-white p-2 rounded-md hover:bg-gray-700" title="Picture-in-Picture"><svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20"><path d="M12.5 5.5h-5a1 1 0 00-1 1v2.5a.5.5 0 001 0v-2a.5.5 0 01.5-.5h4a.5.5 0 01.5.5v4a.5.5 0 01-.5.5h-2a.5.5 0 000 1h2.5a1 1 0 001-1v-5a1 1 0 00-1-1z"></path><path d="M3.5 3A1.5 1.5 0 002 4.5v11A1.5 1.5 0 003.5 17h13a1.5 1.5 0 001.5-1.5v-11A1.5 1.5 0 0016.5 3h-13zm0 1h13a.5.5 0 01.5.5v11a.5.5 0 01-.5.5h-13a.5.5 0 01-.5-.5v-11a.5.5 0 01.5-.5z"></path></svg></button>
                    <button id="close-modal" class="text-gray-400 hover:text-white text-3xl leading-none font-bold">&times;</button>
                </div>
            </div>
            <div class="flex-grow p-1 bg-black"><video id="videoElement" controls autoplay class="w-full h-full"></video></div>
        </div>
    </div>
    
    <div id="program-details-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl w-full max-w-lg p-6">
            <h3 id="details-title" class="text-xl font-bold text-white mb-2"></h3>
            <p id="details-time" class="text-sm text-gray-400 mb-4"></p>
            <p id="details-desc" class="text-base text-gray-300 mb-6 max-h-40 overflow-y-auto custom-scrollbar"></p>
            <div class="flex justify-between items-center gap-4">
                <button id="details-play-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md">Play Channel</button>
                <button id="details-close-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md">Close</button>
            </div>
        </div>
    </div>
    
    <div id="notification-modal" class="hidden fixed top-5 right-5 bg-red-500 text-white py-2 px-4 rounded-lg shadow-lg z-[100]"><p id="notification-message"></p></div>

    <div id="confirm-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl w-full max-w-md p-6">
            <h3 id="confirm-title" class="text-lg font-bold text-white mb-2"></h3>
            <p id="confirm-message" class="text-gray-400 mb-6"></p>
            <div class="flex justify-end gap-4">
                <button id="confirm-cancel-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md">Cancel</button>
                <button id="confirm-ok-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Editor Modal for User Agents and Stream Profiles -->
    <div id="editor-modal" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl w-full max-w-lg p-6">
            <h3 id="editor-title" class="text-xl font-bold text-white mb-4"></h3>
            <form id="editor-form" class="space-y-4">
                <input type="hidden" id="editor-id">
                <input type="hidden" id="editor-type">
                <div>
                    <label for="editor-name" class="block text-sm font-medium text-gray-400">Name</label>
                    <input type="text" id="editor-name" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500" required>
                </div>
                <div id="editor-value-container">
                    <label for="editor-value" id="editor-value-label" class="block text-sm font-medium text-gray-400"></label>
                    <textarea id="editor-value" rows="4" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 text-white focus:ring-blue-500 focus:border-blue-500 custom-scrollbar" required></textarea>
                     <p class="text-xs text-gray-500 mt-1">For ffmpeg commands, use {userAgent} and {streamUrl} as placeholders.</p>
                </div>
                <div class="flex justify-end gap-4 pt-4">
                    <button type="button" id="editor-cancel-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md">Cancel</button>
                    <button type="submit" id="editor-save-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md">Save</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Parser Worker Script -->
    <script id="parser-worker" type="javascript/worker">
        function parseEpgTime(timeStr, offsetHours = 0) {
            const match = timeStr.match(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})\s*(([+-])(\d{2})(\d{2}))?/);
            if (match) {
                const [ , year, month, day, hours, minutes, seconds, , sign, tzHours, tzMinutes] = match;
                let date;
                if (sign && tzHours && tzMinutes) {
                    const epgOffsetMinutes = (parseInt(tzHours) * 60 + parseInt(tzMinutes)) * (sign === '+' ? 1 : -1);
                    date = new Date(Date.UTC(year, parseInt(month) - 1, day, hours, minutes, seconds));
                    date.setUTCMinutes(date.getUTCMinutes() - epgOffsetMinutes);
                } else {
                    date = new Date(Date.UTC(year, parseInt(month) - 1, day, hours, minutes, seconds));
                    date.setUTCHours(date.getUTCHours() - offsetHours);
                }
                return date;
            }
            return new Date();
        }
        function parseM3U(data) {
            const lines = data.split('\n');
            const channels = [];
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line.startsWith('#EXTINF:')) {
                    const nextLine = lines[i + 1]?.trim();
                    if (nextLine && (nextLine.startsWith('http') || nextLine.startsWith('rtp'))) {
                        const idMatch = line.match(/tvg-id="([^"]*)"/);
                        const logoMatch = line.match(/tvg-logo="([^"]*)"/);
                        const nameMatch = line.match(/tvg-name="([^"]*)"/);
                        const groupMatch = line.match(/group-title="([^"]*)"/);
                        const commaIndex = line.lastIndexOf(',');
                        const displayName = (commaIndex !== -1) ? line.substring(commaIndex + 1).trim() : 'Unknown';
                        channels.push({
                            id: idMatch ? idMatch[1] : `unknown-${Math.random()}`,
                            logo: logoMatch ? logoMatch[1] : '',
                            name: nameMatch ? nameMatch[1] : displayName,
                            group: groupMatch ? groupMatch[1] : 'Uncategorized',
                            displayName: displayName,
                            url: nextLine
                        });
                        i++;
                    }
                }
            }
            return channels;
        }
        function parseEPG(xmlString, timezoneOffset) {
            const programData = {};
            const programmeRegex = /<programme([^>]+)>([\s\S]*?)<\/programme>/g;
            const channelRegex = /channel="([^"]+)"/;
            const startRegex = /start="([^"]+)"/;
            const stopRegex = /stop="([^"]+)"/;
            const titleRegex = /<title[^>]*>([\s\S]*?)<\/title>/;
            const descRegex = /<desc[^>]*>([\s\S]*?)<\/desc>/;
            let match;
            while ((match = programmeRegex.exec(xmlString)) !== null) {
                const [, attributes, content] = match;
                const channelMatch = attributes.match(channelRegex);
                const startMatch = attributes.match(startRegex);
                const stopMatch = attributes.match(stopRegex);
                if (!channelMatch || !startMatch || !stopMatch) continue;
                const channelId = channelMatch[1];
                const titleMatch = content.match(titleRegex);
                if (!programData[channelId]) programData[channelId] = [];
                
                const startDate = parseEpgTime(startMatch[1], timezoneOffset);
                const stopDate = parseEpgTime(stopMatch[1], timezoneOffset);

                programData[channelId].push({
                    start: startDate.toISOString(), 
                    stop: stopDate.toISOString(),
                    title: titleMatch ? titleMatch[1].replace(/<!\[CDATA\[|\]\]>/g, '').trim() : 'No Title',
                    desc: content.match(descRegex)?.[1].replace(/<!\[CDATA\[|\]\]>/g, '').trim() || ''
                });
            }
            for (const channelId in programData) {
                programData[channelId].sort((a, b) => new Date(a.start) - new Date(b.start));
            }
            return programData;
        }
        self.onmessage = function(e) {
            const { type, data, timezoneOffset } = e.data;
            try {
                if (type === 'm3u') self.postMessage({ type: 'm3u-success', data: parseM3U(data) });
                else if (type === 'epg') self.postMessage({ type: 'epg-success', data: parseEPG(data, timezoneOffset) });
            } catch (error) {
                self.postMessage({ type: 'parse-error', error: error.message });
            }
        };
    </script>
    
    <!-- Main Application Script -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Global State & Configuration ---
            const guideState = {
                channels: [],
                programs: {},
                settings: {}, // Populated from server on init
                guideDurationHours: 48,
                hourWidthPixels: window.innerWidth < 768 ? 200 : 300,
                currentDate: new Date(),
                channelGroups: new Set(),
                visibleChannels: [],
            };
            let player, worker, autoRefreshIntervalId, searchDebounceTimer;
            let confirmCallback = null;
            let db = null;
            
            // --- Cache UI Elements ---
            const UIElements = Object.fromEntries(
                [...document.querySelectorAll('[id]')].map(el => [
                    el.id.replace(/-(\w)/g, (match, letter) => letter.toUpperCase()), 
                    el
                ])
            );

            // --- IndexedDB Caching Logic ---
            const DB_NAME = 'ViniPlayDB';
            const DB_VERSION = 1;
            const STORE_NAME = 'guideData';

            function openDB() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    request.onerror = () => reject("Error opening IndexedDB.");
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onupgradeneeded = (event) => {
                        const dbInstance = event.target.result;
                        if (!dbInstance.objectStoreNames.contains(STORE_NAME)) {
                            dbInstance.createObjectStore(STORE_NAME);
                        }
                    };
                });
            }

            async function saveDataToDB(key, data) {
                if (!db) return;
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.put(data, key);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject("Error saving data to DB.");
                });
            }

            async function loadDataFromDB(key) {
                if (!db) return null;
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject("Error loading data from DB.");
                });
            }
            
            async function clearDB() {
                if (!db) return;
                 return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.clear();
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject("Error clearing DB.");
                });
            }

            // --- Server Communication ---
            async function saveSettings() {
                try {
                    await fetch('/api/save/settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(guideState.settings)
                    });
                } catch (error) {
                    console.error("Failed to save settings:", error);
                    showNotification("Could not sync settings with server.", true);
                }
            }
            
            // --- UI Helper Functions ---
            const showNotification = (message, isError = false, duration = 3000) => {
                UIElements.notificationMessage.textContent = message;
                UIElements.notificationModal.className = `fixed top-5 right-5 text-white py-2 px-4 rounded-lg shadow-lg z-[100] ${isError ? 'bg-red-500' : 'bg-green-500'}`;
                UIElements.notificationModal.classList.remove('hidden');
                setTimeout(() => { UIElements.notificationModal.classList.add('hidden'); }, duration);
            };
            
            const navigate = (path) => {
                window.history.pushState({}, path, window.location.origin + path);
                handleRouteChange();
            };

            const switchTab = (activeTab) => {
                 const isGuide = activeTab === 'guide';
                 const newPath = isGuide ? '/tvguide' : '/settings';
                 if (window.location.pathname !== newPath) {
                    navigate(newPath);
                 } else {
                    handleRouteChange();
                 }
            };

            const handleRouteChange = () => {
                const path = window.location.pathname;
                const isGuide = path === '/tvguide' || path === '/';

                ['tabGuide', 'bottomNavGuide'].forEach(id => UIElements[id].classList.toggle('active', isGuide));
                ['tabSettings', 'bottomNavSettings'].forEach(id => UIElements[id].classList.toggle('active', !isGuide));
                
                UIElements.pageGuide.classList.toggle('hidden', !isGuide);
                UIElements.pageGuide.classList.toggle('flex', isGuide);
                UIElements.pageSettings.classList.toggle('hidden', isGuide);
                UIElements.pageSettings.classList.toggle('flex', !isGuide);
                
                UIElements.sidebarToggle.classList.toggle('hidden', !isGuide);
            };
            
            const openModal = (modal) => { modal.classList.replace('hidden', 'flex'); document.body.classList.add('modal-open'); };
            const closeModal = (modal) => {
                modal.classList.replace('flex', 'hidden');
                if (!document.querySelector('.fixed.inset-0.flex')) document.body.classList.remove('modal-open');
            };
            
            const showConfirm = (title, message, callback) => {
                UIElements.confirmTitle.textContent = title;
                UIElements.confirmMessage.textContent = message;
                confirmCallback = callback;
                openModal(UIElements.confirmModal);
            };

            const toggleSidebar = (show) => {
                 UIElements.sidebarOverlay.classList.toggle('hidden', !show);
                 UIElements.channelPanelContainer.classList.toggle('-translate-x-full', !show);
            };

            const setDataSourceTab = (type, source) => {
                const isFile = source === 'file';
                UIElements[`${type}TabFile`].classList.toggle('active', isFile);
                UIElements[`${type}TabUrl`].classList.toggle('active', !isFile);
                UIElements[`${type}ContentFile`].classList.toggle('hidden', !isFile);
                UIElements[`${type}ContentUrl`].classList.toggle('hidden', isFile);
            };

            const updateCustomUrlVisibility = (type) => {
                const selectEl = UIElements[`${type}UrlSelect`];
                const customContainer = UIElements[`${type}CustomContainer`];
                if (selectEl.value === 'custom') {
                    customContainer.classList.remove('hidden');
                } else {
                    customContainer.classList.add('hidden');
                }
            };
            
            // --- Main Application Logic ---
            const setButtonLoadingState = (isLoading) => {
                UIElements.loadGuideBtn.disabled = isLoading;
                UIElements.loadGuideBtnContent.innerHTML = isLoading ?
                    `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span>Loading...</span>` :
                    `<svg class="w-5 h-5 inline-block -mt-1 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg><span>Load Guide & View</span>`;
            };

            const handleGuideLoad = (m3uContent, epgContent) => new Promise((resolve, reject) => {
                if (!worker) return reject("Worker not initialized!");
                if (!m3uContent) {
                    guideState.channels = [];
                    guideState.programs = {};
                    finalizeGuideLoad(true);
                    return resolve();
                }
                let m3uParsed = false;
                let epgParsed = !epgContent;
                const checkCompletion = async () => {
                    if (m3uParsed && epgParsed) { 
                        try {
                            await saveDataToDB('channels', guideState.channels);
                            await saveDataToDB('programs', guideState.programs);
                            console.log("Guide data cached in IndexedDB.");
                        } catch (e) {
                            console.error("Failed to cache guide data:", e);
                        }
                        finalizeGuideLoad(true);
                        resolve(); 
                        worker.onmessage = null; 
                    }
                };
                worker.onmessage = ({ data: { type, data, error } }) => {
                    if (error) { reject(new Error(error)); worker.onmessage = null; return; }
                    if (type === 'm3u-success') {
                        guideState.channels = data;
                        m3uParsed = true;
                    } else if (type === 'epg-success') {
                        guideState.programs = data;
                        epgParsed = true;
                    }
                    checkCompletion();
                };
                guideState.programs = {};
                worker.postMessage({ type: 'm3u', data: m3uContent });
                if (!epgParsed) {
                    worker.postMessage({ type: 'epg', data: epgContent, timezoneOffset: guideState.settings.timezoneOffset });
                }
            });

            const finalizeGuideLoad = (isFirstLoad = false) => {
                (guideState.settings.favorites || []).forEach(favId => {
                    const channel = guideState.channels.find(c => c.id === favId);
                    if (channel) channel.isFavorite = true;
                });
                guideState.channelGroups.clear();
                guideState.channels.forEach(ch => { if(ch.group) guideState.channelGroups.add(ch.group) });
                populateGroupFilter();
                handleSearchAndFilter(isFirstLoad);
            };
            
            const populateGroupFilter = () => {
                const currentVal = UIElements.groupFilter.value;
                UIElements.groupFilter.innerHTML = `<option value="all">All Groups</option><option value="recents">Recents</option><option value="favorites">Favorites</option>`;
                [...guideState.channelGroups].sort((a, b) => a.localeCompare(b)).forEach(group => {
                    const cleanGroup = group.replace(/"/g, '&quot;');
                    UIElements.groupFilter.innerHTML += `<option value="${cleanGroup}">${group}</option>`;
                });
                UIElements.groupFilter.value = currentVal || 'all';
                UIElements.groupFilter.classList.remove('hidden');
            };

            const renderGuide = (channelsToRender, resetScroll = false) => {
                guideState.visibleChannels = channelsToRender;
                const showNoData = guideState.channels.length === 0;

                UIElements.guidePlaceholder.classList.toggle('hidden', !showNoData);
                UIElements.noDataMessage.classList.toggle('hidden', !showNoData);
                UIElements.initialLoadingIndicator.classList.add('hidden');

                if(showNoData) {
                   ['channelPanelContainer', 'resizer', 'logoColumn', 'timelineContainer'].forEach(id => UIElements[id].classList.add('hidden'));
                   return;
                }
                
                ['channelPanelContainer', 'resizer', 'logoColumn', 'timelineContainer'].forEach(id => UIElements[id].classList.remove('hidden'));
                
                const currentScrollTop = UIElements.channelList.scrollTop;
                ['channelList', 'logoList', 'guideTimeline'].forEach(id => UIElements[id].innerHTML = '');
                UIElements.timeBar.innerHTML = '';
                UIElements.guideTimeline.innerHTML = '<div id="now-line" class="absolute top-0 bottom-0 bg-red-500 w-0.5 z-20 hidden"></div>';
                
                UIElements.guideDateDisplay.textContent = guideState.currentDate.toLocaleDateString([], { weekday: 'short', month: 'long', day: 'numeric' });
                const timeBarContent = document.createElement('div');
                timeBarContent.className = 'relative h-full';
                timeBarContent.style.width = `${guideState.guideDurationHours * guideState.hourWidthPixels}px`;
                const guideStart = new Date(guideState.currentDate);
                guideStart.setHours(0, 0, 0, 0);
                for (let i = 0; i < guideState.guideDurationHours; i++) {
                    const time = new Date(guideStart); time.setHours(guideStart.getHours() + i);
                    timeBarContent.innerHTML += `<div class="absolute top-0 bottom-0 flex items-center justify-start px-2 text-xs text-gray-400 border-r border-gray-700/50" style="left: ${i * guideState.hourWidthPixels}px; width: ${guideState.hourWidthPixels}px;">${time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>`;
                }
                UIElements.timeBar.appendChild(timeBarContent);
                
                const now = new Date();
                const guideEnd = new Date(guideStart.getTime() + guideState.guideDurationHours * 3600 * 1000);
                let channelRowsHTML = '';
                channelsToRender.forEach(channel => {
                    UIElements.channelList.innerHTML += `<div class="h-20 flex items-center justify-between p-2 border-b border-gray-700/50 flex-shrink-0"><div class="flex items-center overflow-hidden cursor-pointer flex-grow min-w-0" data-url="${channel.url}" data-name="${channel.displayName || channel.name}" data-id="${channel.id}"><img src="${channel.logo}" onerror="this.onerror=null; this.src='https://placehold.co/48x48/1f2937/d1d5db?text=?';" class="w-12 h-12 object-contain mr-3 flex-shrink-0 rounded-md bg-gray-700"><span class="font-semibold text-sm truncate">${channel.displayName || channel.name}</span></div><svg data-channel-id="${channel.id}" class="w-6 h-6 text-gray-500 hover:text-yellow-400 favorite-star cursor-pointer flex-shrink-0 ml-2 ${channel.isFavorite ? 'favorited' : ''}" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8-2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"></path></svg></div>`;
                    UIElements.logoList.innerHTML += `<div class="h-20 flex items-center justify-center p-1 border-b border-gray-700/50 flex-shrink-0 cursor-pointer" data-url="${channel.url}" data-name="${channel.displayName || channel.name}" data-id="${channel.id}"><img src="${channel.logo}" onerror="this.onerror=null; this.src='https://placehold.co/48x48/1f2937/d1d5db?text=?';" class="w-14 h-14 object-contain pointer-events-none"></div>`;
                    let programsHTML = '';
                    (guideState.programs[channel.id] || []).forEach(prog => {
                        const progStart = new Date(prog.start);
                        const progStop = new Date(prog.stop);
                        if (progStop < guideStart || progStart > guideEnd) return;
                        const durationMs = progStop - progStart;
                        if (durationMs <= 0) return;
                        const left = ((progStart - guideStart) / 3600000) * guideState.hourWidthPixels;
                        const width = (durationMs / 3600000) * guideState.hourWidthPixels;
                        const isLive = now > progStart && now < progStop;
                        const progressWidth = isLive ? ((now - progStart) / durationMs) * 100 : 0;
                        programsHTML += `<div class="programme-item absolute top-1 bottom-1 bg-gray-800 rounded-md p-2 overflow-hidden flex flex-col justify-center z-5 ${isLive ? 'live' : ''} ${progStop < now ? 'past' : ''}" style="left:${left}px; width:${Math.max(0, width - 2)}px" data-channel-url="${channel.url}" data-channel-id="${channel.id}" data-channel-name="${channel.name}" data-prog-title="${prog.title}" data-prog-desc="${prog.desc}" data-prog-start="${progStart.toISOString()}" data-prog-stop="${progStop.toISOString()}"><div class="programme-progress" style="width:${progressWidth}%"></div><p class="prog-title text-white font-semibold truncate relative z-10">${prog.title}</p><p class="prog-time text-gray-400 truncate relative z-10">${progStart.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})} - ${progStop.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}</p></div>`;
                    });
                    channelRowsHTML += `<div class="h-20 border-b border-gray-700/50 relative">${programsHTML}</div>`;
                });
                UIElements.guideTimeline.insertAdjacentHTML('beforeend', channelRowsHTML);
                
                const totalGuideHeight = channelsToRender.length * 80;
                setTimeout(() => {
                    UIElements.channelList.scrollTop = resetScroll ? 0 : currentScrollTop;
                    UIElements.guideTimeline.scrollTop = UIElements.channelList.scrollTop;
                    UIElements.logoList.scrollTop = UIElements.channelList.scrollTop;
                    updateNowLine(guideStart, resetScroll, totalGuideHeight);
                }, 0);
            };

            // MODIFIED: This function now correctly updates program states
            const updateNowLine = (guideStart, shouldScroll, totalGuideHeight) => {
                const nowLineEl = document.getElementById('now-line');
                if (!nowLineEl) return;
                nowLineEl.style.height = `${totalGuideHeight}px`;
                const now = new Date();
                const guideEnd = new Date(guideStart.getTime() + guideState.guideDurationHours * 3600 * 1000);
                
                // Update Now Line position
                if (now >= guideStart && now <= guideEnd) {
                    const left = ((now - guideStart) / 3600000) * guideState.hourWidthPixels;
                    nowLineEl.style.left = `${left}px`;
                    nowLineEl.classList.remove('hidden');
                    if (shouldScroll) UIElements.guideTimeline.scrollLeft = left - (UIElements.guideTimeline.clientWidth / 4);
                } else {
                    nowLineEl.classList.add('hidden');
                }

                // Update program states (live/past) every minute
                document.querySelectorAll('.programme-item').forEach(item => {
                    const progStart = new Date(item.dataset.progStart);
                    const progStop = new Date(item.dataset.progStop);

                    const isLive = now >= progStart && now < progStop;
                    const isPast = now >= progStop;

                    item.classList.toggle('live', isLive);
                    item.classList.toggle('past', isPast);

                    // Update progress bar only if it's live
                    if (isLive) {
                        const progressEl = item.querySelector('.programme-progress');
                        if (progressEl) {
                            const durationMs = progStop - progStart;
                            const elapsedMs = now - progStart;
                            progressEl.style.width = `${(elapsedMs / durationMs) * 100}%`;
                        }
                    }
                });

                setTimeout(() => updateNowLine(guideStart, false, totalGuideHeight), 60000);
            };

            const stopAndCleanupPlayer = () => {
                if (player) { player.destroy(); player = null; }
                UIElements.videoElement.src = "";
                UIElements.videoElement.removeAttribute('src');
                UIElements.videoElement.load();
                if (document.pictureInPictureElement) document.exitPictureInPicture().catch(console.error);
                closeModal(UIElements.videoModal);
            };

            const playChannel = async (url, name, channelId) => {
                if (player) stopAndCleanupPlayer();
                if(channelId) {
                    guideState.settings.recentChannels = [channelId, ...(guideState.settings.recentChannels || []).filter(id => id !== channelId)].slice(0, 15);
                    await saveSettings();
                }
                
                const profileId = guideState.settings.activeStreamProfileId;
                const profile = (guideState.settings.streamProfiles || []).find(p => p.id === profileId);

                if (!profile) {
                    showNotification("No stream profile selected. Please check settings.", true);
                    return;
                }
                
                let streamUrlToPlay;
                if (profile.command === 'redirect') {
                    streamUrlToPlay = url;
                } else {
                    const userAgentId = guideState.settings.activeUserAgentId;
                    if (!userAgentId) {
                         showNotification("No user agent selected. Please check settings.", true);
                         return;
                    }
                    streamUrlToPlay = `/stream?url=${encodeURIComponent(url)}&profileId=${profileId}&userAgentId=${userAgentId}`;
                }

                if (mpegts.isSupported()) {
                    player = mpegts.createPlayer({ type: 'mse', isLive: true, url: streamUrlToPlay });
                    openModal(UIElements.videoModal);
                    UIElements.videoTitle.textContent = name;
                    player.attachMediaElement(UIElements.videoElement);
                    player.load();
                    UIElements.videoElement.volume = parseFloat(localStorage.getItem('iptvPlayerVolume') || 0.5);
                    player.play().catch((err) => {
                        console.error("MPEGTS Player Error:", err)
                        showNotification("Could not play stream. Check browser console & server logs.", true);
                        stopAndCleanupPlayer();
                    });
                } else {
                    showNotification('Your browser does not support MSE.', true);
                }
            };
            
            const setupAutoRefresh = (hours) => {
                clearInterval(autoRefreshIntervalId);
                if (hours > 0) {
                    autoRefreshIntervalId = setInterval(() => {
                        if (guideState.settings.m3uSourceType === 'url' || guideState.settings.epgSourceType === 'url') {
                            showNotification(`Auto-refreshing guide data...`);
                            UIElements.loadGuideBtn.click();
                        }
                    }, hours * 3600 * 1000);
                }
            };

            const addUrlToSelect = (selectEl, url, makeActive) => {
                if ([...selectEl.options].some(opt => opt.value === url)) {
                    if (makeActive) selectEl.value = url;
                    return;
                }
                const option = document.createElement('option');
                option.value = url;
                option.textContent = url.length > 60 ? url.substring(0, 57) + '...' : url;
                selectEl.insertBefore(option, selectEl.querySelector('option[value="custom"]'));
                if (makeActive) selectEl.value = url;
            };

            const saveCustomUrl = async (type) => {
                const inputEl = UIElements[`${type}UrlInput`];
                const url = inputEl.value.trim();
                if (!url) return showNotification('URL cannot be empty.', true);
                try {
                    new URL(url);
                    const response = await fetch('/api/save/url', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ type, url }),
                    });
                    const result = await response.json();
                    if (!response.ok) throw new Error(result.error);
                    
                    guideState.settings = result.settings;
                    updateUIFromSettings();
                    showNotification(`${type.toUpperCase()} URL saved and selected.`);

                } catch (e) {
                    showNotification(`Error: ${e.message}`, true);
                }
            };
            
            const handleSearchAndFilter = (isFirstLoad = false) => {
                const searchTerm = UIElements.searchInput.value.toLowerCase().trim();
                const selectedGroup = UIElements.groupFilter.value;
                let filteredChannels = guideState.channels;
                
                if (selectedGroup !== 'all') {
                    if (selectedGroup === 'favorites') {
                        const favoriteIds = new Set(guideState.settings.favorites || []);
                        filteredChannels = guideState.channels.filter(ch => favoriteIds.has(ch.id));
                    } else if (selectedGroup === 'recents') {
                        const recentIds = guideState.settings.recentChannels || [];
                        filteredChannels = recentIds.map(id => guideState.channels.find(ch => ch.id === id)).filter(Boolean);
                    } else {
                        filteredChannels = guideState.channels.filter(ch => ch.group === selectedGroup);
                    }
                }

                UIElements.searchResultsContainer.innerHTML = '';
                let channelsForGuide = filteredChannels;
                
                if (searchTerm) {
                    channelsForGuide = filteredChannels.filter(ch => (ch.displayName || ch.name).toLowerCase().includes(searchTerm));
                    
                    const searchPrograms = guideState.settings.searchScope === 'channels_programs';
                    const programResults = [];
                    
                    if (searchPrograms) {
                        const guideStart = new Date(guideState.currentDate);
                        guideStart.setHours(0, 0, 0, 0);
                        const guideEnd = new Date(guideStart.getTime() + guideState.guideDurationHours * 3600 * 1000);

                        for (const channel of guideState.channels) {
                            for (const prog of (guideState.programs[channel.id] || [])) {
                                const progStart = new Date(prog.start);
                                const progStop = new Date(prog.stop);
                                if (progStop < guideStart || progStart > guideEnd) continue;
                                if (prog.title.toLowerCase().includes(searchTerm)) {
                                    programResults.push({ channel, program: prog });
                                    if (programResults.length >= 50) break;
                                }
                            }
                            if (programResults.length >= 50) break;
                        }
                    }

                    if (programResults.length > 0) {
                        UIElements.searchResultsContainer.innerHTML = `<div class="p-2 bg-gray-700 text-xs font-bold text-gray-400">PROGRAM RESULTS</div>` +
                        programResults.map(({ channel, program }) => `
                            <div class="search-result-program p-3 border-b border-gray-700 hover:bg-gray-700 cursor-pointer" data-channel-id="${channel.id}" data-prog-start="${program.start}">
                                <p class="font-semibold text-white text-sm truncate">${program.title}</p>
                                <p class="text-gray-400 text-xs truncate">${channel.name}</p>
                            </div>
                        `).join('');
                        UIElements.searchResultsContainer.classList.remove('hidden');
                    } else {
                         UIElements.searchResultsContainer.classList.add('hidden');
                    }
                } else {
                    UIElements.searchResultsContainer.classList.add('hidden');
                }
                
                renderGuide(channelsForGuide, isFirstLoad);
            };
            
            const populateTimezoneSelector = () => {
                UIElements.timezoneOffsetSelect.innerHTML = '';
                for (let i = 14; i >= -12; i--) {
                    UIElements.timezoneOffsetSelect.innerHTML += `<option value="${i}">UTC${i >= 0 ? '+' : ''}${i}:00</option>`;
                }
            };

            const openEditorModal = (type, item = null) => {
                const isUserAgent = type === 'userAgent';
                const title = item ? `Edit ${isUserAgent ? 'User Agent' : 'Stream Profile'}` : `Create New ${isUserAgent ? 'User Agent' : 'Stream Profile'}`;
                const valueLabel = isUserAgent ? 'User Agent String' : 'Command';
                
                UIElements.editorTitle.textContent = title;
                UIElements.editorType.value = type;
                UIElements.editorId.value = item ? item.id : `custom-${Date.now()}`;
                UIElements.editorName.value = item ? item.name : '';
                UIElements.editorValueLabel.textContent = valueLabel;
                UIElements.editorValue.value = item ? (isUserAgent ? item.value : item.command) : '';
                
                const isDefault = item && item.isDefault;
                UIElements.editorName.disabled = isDefault;
                UIElements.editorValue.disabled = isDefault; 

                if (isDefault && !isUserAgent) { 
                    const helpText = item.command === 'redirect'
                        ? 'This built-in profile redirects the player to the stream URL directly. The command cannot be changed.'
                        : 'This built-in profile uses the server to proxy the stream. The command cannot be changed.';
                    UIElements.editorValue.value = helpText;
                }
                
                UIElements.editorSaveBtn.disabled = isDefault;
                openModal(UIElements.editorModal);
            };

            function setupEventListeners() {
                // Main Navigation
                ['tabGuide', 'bottomNavGuide'].forEach(id => UIElements[id].addEventListener('click', () => switchTab('guide')));
                ['tabSettings', 'bottomNavSettings'].forEach(id => UIElements[id].addEventListener('click', () => switchTab('settings')));
                window.addEventListener('popstate', handleRouteChange);

                // Modals
                UIElements.confirmCancelBtn.addEventListener('click', () => closeModal(UIElements.confirmModal));
                UIElements.confirmOkBtn.addEventListener('click', () => { if (confirmCallback) confirmCallback(); closeModal(UIElements.confirmModal); });
                UIElements.detailsCloseBtn.addEventListener('click', () => closeModal(UIElements.programDetailsModal));
                UIElements.closeModal.addEventListener('click', () => document.pictureInPictureElement ? closeModal(UIElements.videoModal) : stopAndCleanupPlayer());
                UIElements.pipBtn.addEventListener('click', () => {
                    if(document.pictureInPictureEnabled && UIElements.videoElement.readyState === 4) {
                        UIElements.videoElement.requestPictureInPicture().catch(console.error);
                    }
                });
                UIElements.videoElement.addEventListener('leavepictureinpicture', stopAndCleanupPlayer);
                UIElements.videoElement.addEventListener('volumechange', () => localStorage.setItem('iptvPlayerVolume', UIElements.videoElement.volume));

                // Guide Interaction
                UIElements.sidebarToggle.addEventListener('click', () => toggleSidebar(true));
                UIElements.sidebarOverlay.addEventListener('click', () => toggleSidebar(false));
                UIElements.channelList.addEventListener('click', async (e) => {
                    const favoriteStar = e.target.closest('.favorite-star');
                    if (favoriteStar) {
                        const channelId = favoriteStar.dataset.channelId;
                        const channel = guideState.channels.find(c => c.id === channelId);
                        if (!channel) return;
                        channel.isFavorite = !channel.isFavorite;
                        favoriteStar.classList.toggle('favorited', channel.isFavorite);
                        guideState.settings.favorites = guideState.channels.filter(c => c.isFavorite).map(c => c.id);
                        await saveSettings();
                        if (UIElements.groupFilter.value === 'favorites') handleSearchAndFilter();
                        return;
                    }
                    const channelItem = e.target.closest('div[data-url]');
                    if (channelItem) {
                        playChannel(channelItem.dataset.url, channelItem.dataset.name, channelItem.dataset.id);
                        if (window.innerWidth < 1024) toggleSidebar(false);
                    }
                });
                UIElements.guideTimeline.addEventListener('click', (e) => {
                    const progItem = e.target.closest('.programme-item');
                    if (!progItem) return;
                    UIElements.detailsTitle.textContent = progItem.dataset.progTitle;
                    const progStart = new Date(progItem.dataset.progStart);
                    const progStop = new Date(progItem.dataset.progStop);
                    UIElements.detailsTime.textContent = `${progStart.toLocaleTimeString([],{hour:'2-digit', minute:'2-digit'})} - ${progStop.toLocaleTimeString([],{hour:'2-digit', minute:'2-digit'})}`;
                    UIElements.detailsDesc.textContent = progItem.dataset.progDesc || "No description available.";
                    UIElements.detailsPlayBtn.onclick = () => {
                        playChannel(progItem.dataset.channelUrl, `${progItem.dataset.channelName} - ${progItem.dataset.progTitle}`, progItem.dataset.channelId);
                        closeModal(UIElements.programDetailsModal);
                    };
                    openModal(UIElements.programDetailsModal);
                });
                UIElements.searchResultsContainer.addEventListener('click', e => {
                    const progItemData = e.target.closest('.search-result-program');
                    if (progItemData) {
                        const progStart = new Date(progItemData.dataset.progStart);
                        guideState.currentDate = progStart;
                        handleSearchAndFilter();
                        setTimeout(() => {
                            const guideStartTime = new Date(guideState.currentDate);
                            guideStartTime.setHours(0,0,0,0);
                            const channelIndex = guideState.visibleChannels.findIndex(ch => ch.id === progItemData.dataset.channelId);
                            if (channelIndex === -1) return;
                            const hScroll = ((progStart - guideStartTime) / 3600000) * guideState.hourWidthPixels;
                            UIElements.guideTimeline.scrollTo({ top: channelIndex * 80, left: hScroll - (UIElements.guideTimeline.clientWidth / 4), behavior: 'smooth' });
                        }, 150);
                        UIElements.searchResultsContainer.classList.add('hidden');
                        UIElements.searchInput.value = '';
                    }
                });

                // Guide Navigation
                UIElements.prevDayBtn.addEventListener('click', () => { guideState.currentDate.setDate(guideState.currentDate.getDate() - 1); handleSearchAndFilter(); });
                UIElements.todayBtn.addEventListener('click', () => { guideState.currentDate = new Date(); renderGuide(guideState.visibleChannels, true); });
                UIElements.nowBtn.addEventListener('click', () => {
                    const now = new Date();
                    if (guideState.currentDate.toDateString() !== now.toDateString()) {
                        guideState.currentDate = now;
                        renderGuide(guideState.visibleChannels, true);
                    } else {
                        const guideStart = new Date(guideState.currentDate); guideStart.setHours(0,0,0,0);
                        UIElements.guideTimeline.scrollTo({ left: ((now - guideStart) / 3600000) * guideState.hourWidthPixels - (UIElements.guideTimeline.clientWidth / 4), behavior: 'smooth' });
                    }
                });
                UIElements.nextDayBtn.addEventListener('click', () => { guideState.currentDate.setDate(guideState.currentDate.getDate() + 1); handleSearchAndFilter(); });
                
                UIElements.groupFilter.addEventListener('change', () => handleSearchAndFilter());

                // Settings: Data Sources
                ['m3u', 'epg'].forEach(type => {
                    UIElements[`${type}TabFile`].addEventListener('click', () => { setDataSourceTab(type, 'file'); guideState.settings[`${type}SourceType`] = 'file'; saveSettings(); });
                    UIElements[`${type}TabUrl`].addEventListener('click', () => { setDataSourceTab(type, 'url'); guideState.settings[`${type}SourceType`] = 'url'; saveSettings(); });
                    UIElements[`${type}UrlSelect`].addEventListener('change', () => {
                        updateCustomUrlVisibility(type);
                        const selectedUrl = UIElements[`${type}UrlSelect`].value;
                        if (selectedUrl !== 'custom') { guideState.settings[`${type}Url`] = selectedUrl; UIElements[`${type}UrlInput`].value = selectedUrl; } 
                        else { guideState.settings[`${type}Url`] = ''; UIElements[`${type}UrlInput`].value = ''; }
                        saveSettings();
                    });
                    UIElements[`save${type.charAt(0).toUpperCase() + type.slice(1)}UrlBtn`].addEventListener('click', () => saveCustomUrl(type));
                });
                
                UIElements.loadGuideBtn.addEventListener('click', async () => {
                    setButtonLoadingState(true);
                    try {
                        const { m3uSourceType, epgSourceType } = guideState.settings;
                        if (m3uSourceType === 'file' || epgSourceType === 'file') {
                            const formData = new FormData();
                            if (m3uSourceType === 'file' && UIElements.m3uUpload.files[0]) formData.append('m3u-file', UIElements.m3uUpload.files[0]);
                            if (epgSourceType === 'file' && UIElements.epgUpload.files[0]) formData.append('epg-file', UIElements.epgUpload.files[0]);
                            if (formData.has('m3u-file') || formData.has('epg-file')) {
                                const res = await fetch('/api/upload', { method: 'POST', body: formData });
                                if (!res.ok) throw new Error('File upload failed on server.');
                            }
                        }
                        if (m3uSourceType === 'url' && UIElements.m3uUrlInput.value.trim()) {
                            await fetch(`/fetch-m3u?url=${encodeURIComponent(UIElements.m3uUrlInput.value.trim())}`);
                        }
                        if (epgSourceType === 'url' && UIElements.epgUrlInput.value.trim()) {
                           await fetch(`/fetch-epg?url=${encodeURIComponent(UIElements.epgUrlInput.value.trim())}`);
                        }
                        
                        const configResponse = await fetch(`/api/config?t=${new Date().getTime()}`);
                        const config = await configResponse.json();
                        if (!configResponse.ok) throw new Error('Could not retrieve config from server.');
                        if (!config.m3uContent) throw new Error("No M3U data found. Please select a valid source.");
                        
                        await handleGuideLoad(config.m3uContent, config.epgContent);
                        
                        guideState.settings = config.settings || {};
                        updateUIFromSettings();
                        navigate('/tvguide');
                        showNotification('Guide data loaded successfully!');
                    } catch (error) {
                        showNotification(`Error: ${error.message}`, true);
                    } finally {
                        setButtonLoadingState(false);
                    }
                });

                // Settings: General
                UIElements.clearDataBtn.addEventListener('click', () => {
                    showConfirm('Clear All Data?', 'This will permanently delete ALL settings and files from the server and browser cache. The page will reload.', async () => {
                        try {
                            await fetch('/api/data', { method: 'DELETE' });
                            await clearDB();
                            showNotification('All data cleared. Reloading...');
                            setTimeout(() => window.location.reload(), 1500);
                        } catch (e) { showNotification(e.message, true); }
                    });
                });
                UIElements.autoRefreshSelect.addEventListener('change', async (e) => { guideState.settings.autoRefresh = parseInt(e.target.value, 10); await saveSettings(); setupAutoRefresh(guideState.settings.autoRefresh); });
                UIElements.timezoneOffsetSelect.addEventListener('change', async (e) => { 
                    guideState.settings.timezoneOffset = parseInt(e.target.value, 10); 
                    await saveSettings();
                    await clearDB(); 
                    showNotification(`Timezone offset set. Reload guide to apply changes.`); 
                });
                UIElements.searchScopeSelect.addEventListener('change', async (e) => {
                    guideState.settings.searchScope = e.target.value;
                    await saveSettings();
                    showNotification('Search scope updated.');
                });
                
                // Settings: Player CRUD
                UIElements.addUserAgentBtn.addEventListener('click', () => openEditorModal('userAgent'));
                UIElements.editUserAgentBtn.addEventListener('click', () => {
                    const selectedId = UIElements.userAgentSelect.value;
                    const agent = guideState.settings.userAgents.find(ua => ua.id === selectedId);
                    if (agent) openEditorModal('userAgent', agent);
                });
                UIElements.deleteUserAgentBtn.addEventListener('click', () => {
                    const selectedId = UIElements.userAgentSelect.value;
                    if (!selectedId) return;
                    showConfirm('Delete User Agent?', 'Are you sure you want to delete this user agent?', async () => {
                        guideState.settings.userAgents = guideState.settings.userAgents.filter(ua => ua.id !== selectedId);
                        if (guideState.settings.activeUserAgentId === selectedId) {
                           guideState.settings.activeUserAgentId = guideState.settings.userAgents[0]?.id || null;
                        }
                        await saveSettings();
                        updateUIFromSettings();
                        showNotification('User Agent deleted.');
                    });
                });
                UIElements.addStreamProfileBtn.addEventListener('click', () => openEditorModal('streamProfile'));
                UIElements.editStreamProfileBtn.addEventListener('click', () => {
                    const selectedId = UIElements.streamProfileSelect.value;
                    const profile = guideState.settings.streamProfiles.find(p => p.id === selectedId);
                    if (profile) openEditorModal('streamProfile', profile);
                });
                UIElements.deleteStreamProfileBtn.addEventListener('click', () => {
                    const selectedId = UIElements.streamProfileSelect.value;
                    const profile = guideState.settings.streamProfiles.find(p => p.id === selectedId);
                    if (!profile || profile.isDefault) return;
                    showConfirm('Delete Stream Profile?', 'Are you sure you want to delete this profile?', async () => {
                        guideState.settings.streamProfiles = guideState.settings.streamProfiles.filter(p => p.id !== selectedId);
                         if (guideState.settings.activeStreamProfileId === selectedId) {
                           guideState.settings.activeStreamProfileId = guideState.settings.streamProfiles[0]?.id || null;
                        }
                        await saveSettings();
                        updateUIFromSettings();
                        showNotification('Stream Profile deleted.');
                    });
                });
                
                // Settings: Player Selections
                UIElements.userAgentSelect.addEventListener('change', async (e) => {
                    guideState.settings.activeUserAgentId = e.target.value;
                    await saveSettings();
                    showNotification('Active User Agent set.', false, 2000);
                });
                UIElements.streamProfileSelect.addEventListener('change', async (e) => {
                    guideState.settings.activeStreamProfileId = e.target.value;
                    updateUIFromSettings(); 
                    await saveSettings();
                    showNotification('Active Stream Profile set.', false, 2000);
                });

                // Settings: Editor Modal
                UIElements.editorCancelBtn.addEventListener('click', () => closeModal(UIElements.editorModal));
                UIElements.editorForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const id = UIElements.editorId.value;
                    const type = UIElements.editorType.value;
                    const name = UIElements.editorName.value.trim();
                    const value = UIElements.editorValue.value.trim();
                    if (!name || !value) return showNotification('Name and value cannot be empty.', true);

                    const isNew = type === 'userAgent' 
                        ? !guideState.settings.userAgents.some(ua => ua.id === id)
                        : !guideState.settings.streamProfiles.some(p => p.id === id);

                    if (type === 'userAgent') {
                        const existingIndex = guideState.settings.userAgents.findIndex(ua => ua.id === id);
                        if (existingIndex > -1) guideState.settings.userAgents[existingIndex] = { ...guideState.settings.userAgents[existingIndex], name, value };
                        else guideState.settings.userAgents.push({ id, name, value });
                    } else { // streamProfile
                        const existingIndex = guideState.settings.streamProfiles.findIndex(p => p.id === id);
                        if (existingIndex > -1) guideState.settings.streamProfiles[existingIndex] = { ...guideState.settings.streamProfiles[existingIndex], name, command: value };
                        else guideState.settings.streamProfiles.push({ id, name, command: value, isDefault: false });
                    }
                    
                    await saveSettings();
                    updateUIFromSettings();
                    closeModal(UIElements.editorModal);
                    const typeName = type === 'userAgent' ? 'User Agent' : 'Stream Profile';
                    showNotification(isNew ? `${typeName} created.` : `${typeName} updated.`);
                });
                
                // Search and scroll sync
                UIElements.searchInput.addEventListener('input', () => { clearTimeout(searchDebounceTimer); searchDebounceTimer = setTimeout(() => handleSearchAndFilter(false), 300); });
                document.addEventListener('click', e => { if (!UIElements.searchInput.contains(e.target) && !UIElements.searchResultsContainer.contains(e.target)) UIElements.searchResultsContainer.classList.add('hidden'); });
                let ignoreScroll = false;
                const syncScroll = (source, targets) => { if (!ignoreScroll) { ignoreScroll = true; targets.forEach(target => { if (target) target.scrollTop = source.scrollTop; }); ignoreScroll = false; } };
                UIElements.guideTimeline.addEventListener('scroll', (e) => { UIElements.timeBar.scrollLeft = e.target.scrollLeft; syncScroll(e.target, [UIElements.channelList, UIElements.logoList]); });
                UIElements.channelList.addEventListener('scroll', (e) => syncScroll(e.target, [UIElements.guideTimeline, UIElements.logoList]));
                UIElements.logoList.addEventListener('scroll', (e) => syncScroll(e.target, [UIElements.guideTimeline, UIElements.channelList]));

                // Resizer
                UIElements.resizer.addEventListener('mousedown', e => {
                    e.preventDefault();
                    const startX = e.clientX, startWidth = UIElements.channelPanelContainer.offsetWidth;
                    const doResize = (e) => UIElements.channelPanelContainer.style.width = `${Math.max(250, startWidth + e.clientX - startX)}px`;
                    const stopResize = () => { window.removeEventListener('mousemove', doResize); window.removeEventListener('mouseup', stopResize); };
                    window.addEventListener('mousemove', doResize);
                    window.addEventListener('mouseup', stopResize);
                }, false);
            }

            const updateUIFromSettings = () => {
                const settings = guideState.settings;
                
                settings.timezoneOffset = settings.timezoneOffset ?? Math.round(-(new Date().getTimezoneOffset() / 60));
                settings.autoRefresh = settings.autoRefresh || 0;
                settings.m3uSourceType = settings.m3uSourceType || 'url';
                settings.epgSourceType = settings.epgSourceType || 'url';
                settings.searchScope = settings.searchScope || 'channels_programs';
                
                UIElements.timezoneOffsetSelect.value = settings.timezoneOffset;
                UIElements.autoRefreshSelect.value = settings.autoRefresh;
                UIElements.searchScopeSelect.value = settings.searchScope;
                setupAutoRefresh(settings.autoRefresh);
                
                ['m3u', 'epg'].forEach(type => {
                    setDataSourceTab(type, settings[`${type}SourceType`]);
                    const selectEl = UIElements[`${type}UrlSelect`];
                    selectEl.innerHTML = '<option value="custom">Custom URL...</option>';
                    (settings[`${type}CustomUrls`] || []).forEach(url => addUrlToSelect(selectEl, url, false));
                    const activeUrl = settings[`${type}Url`];
                    if (activeUrl && (settings[`${type}CustomUrls`] || []).includes(activeUrl)) selectEl.value = activeUrl;
                    else selectEl.value = 'custom';
                    UIElements[`${type}UrlInput`].value = activeUrl || '';
                    updateCustomUrlVisibility(type);
                });

                const populateSelect = (selectId, items, activeId) => {
                    const selectEl = UIElements[selectId];
                    selectEl.innerHTML = '';
                    items.forEach(item => {
                        const option = document.createElement('option');
                        option.value = item.id;
                        option.textContent = item.name; 
                        selectEl.appendChild(option);
                    });
                    if (activeId) {
                        selectEl.value = activeId;
                    }
                };

                populateSelect('userAgentSelect', settings.userAgents || [], settings.activeUserAgentId);
                populateSelect('streamProfileSelect', settings.streamProfiles || [], settings.activeStreamProfileId);

                const selectedProfileId = UIElements.streamProfileSelect.value;
                const selectedProfile = (settings.streamProfiles || []).find(p => p.id === selectedProfileId);
                UIElements.editStreamProfileBtn.disabled = !selectedProfile;
                UIElements.deleteStreamProfileBtn.disabled = !selectedProfile || selectedProfile.isDefault;
                const selectedUAId = UIElements.userAgentSelect.value;
                const selectedUA = (settings.userAgents || []).find(ua => ua.id === selectedUAId);
                UIElements.editUserAgentBtn.disabled = !selectedUA;
                UIElements.deleteUserAgentBtn.disabled = !selectedUA || selectedUA.isDefault;
            };

            const initApp = async () => {
                const blob = new Blob([document.querySelector('#parser-worker').textContent], { type: 'text/javascript' });
                worker = new Worker(window.URL.createObjectURL(blob));
                try {
                    db = await openDB();
                } catch(e) {
                    console.error(e);
                    showNotification("Could not initialize local cache.", true);
                }

                populateTimezoneSelector();
                setupEventListeners();
                
                try {
                    const response = await fetch(`/api/config?t=${new Date().getTime()}`);
                    if (!response.ok) throw new Error('Could not connect to the server.');
                    const config = await response.json();
                    guideState.settings = config.settings || {}; 
                    updateUIFromSettings(); 

                    UIElements.initialLoadingIndicator.classList.remove('hidden');
                    UIElements.guidePlaceholder.classList.remove('hidden');

                    const cachedChannels = await loadDataFromDB('channels');
                    const cachedPrograms = await loadDataFromDB('programs');

                    if (cachedChannels && cachedPrograms && cachedChannels.length > 0) {
                        console.log("Loading guide from local cache.");
                        guideState.channels = cachedChannels;
                        guideState.programs = cachedPrograms;
                        finalizeGuideLoad(true);
                    } else if (config.m3uContent) {
                        console.log("Loading guide from server (no cache available).");
                        await handleGuideLoad(config.m3uContent, config.epgContent);
                    } else {
                        UIElements.initialLoadingIndicator.classList.add('hidden');
                        UIElements.noDataMessage.classList.remove('hidden');
                    }
                    
                    handleRouteChange();

                } catch (e) {
                    showNotification("Initialization failed: " + e.message, true);
                    UIElements.initialLoadingIndicator.classList.add('hidden');
                    UIElements.noDataMessage.classList.remove('hidden');
                    navigate('/settings');
                }
            };
            
            initApp();
        });
    </script>
</body>
</html>
